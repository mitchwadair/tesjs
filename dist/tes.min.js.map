{
  "version": 3,
  "sources": ["exclude-whserver:./whserver", "../lib/logger.js", "../lib/events.js", "../lib/utils.js", "../lib/wsclient.js", "../lib/auth.js", "../lib/request.js", "../lib/tes.js"],
  "sourcesContent": ["", "// Copyright (c) 2020-2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst levels = {\r\n    debug: 0,\r\n    error: 1,\r\n    warn: 2,\r\n    info: 3,\r\n    none: 4,\r\n};\r\n\r\nlet level = \"warn\";\r\n\r\nconst log = (lvl) => {\r\n    return (message) => {\r\n        if (levels[lvl] >= levels[level]) {\r\n            console.log(`${new Date().toUTCString()} - TESjs - ${message}`);\r\n        }\r\n    };\r\n};\r\n\r\nmodule.exports = {\r\n    setLevel: (lvl) => (level = lvl),\r\n    debug: log(\"debug\"),\r\n    error: log(\"error\"),\r\n    warn: log(\"warn\"),\r\n    log: log(\"info\"),\r\n};\r\n", "// Copyright (c) 2020 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst logger = require(\"./logger\");\r\n\r\nclass EventManager {\r\n    constructor() {\r\n        EventManager._instance = this;\r\n        this._events = this._events || {};\r\n        this._subscriptionQueue = this._subscriptionQueue || {};\r\n    }\r\n\r\n    fire(sub, data) {\r\n        const handler = this._events[sub.type];\r\n        if (!handler) {\r\n            logger.warn(`Recieved event for unhandled type: ${sub.type}`);\r\n            return false;\r\n        } else {\r\n            handler.call(this, data, sub);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    addListener(type, handler) {\r\n        if (typeof handler !== \"function\") {\r\n            throw TypeError(\"Event handler must be a function\");\r\n        }\r\n\r\n        this._events[type] = handler;\r\n        return this;\r\n    }\r\n\r\n    removeListener(type) {\r\n        if (this._events[type]) {\r\n            delete this._events[type];\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    removeAllListeners() {\r\n        this._events = {};\r\n        return this;\r\n    }\r\n\r\n    queueSubscription(data, resolve, reject) {\r\n        const id = data.data[0].id;\r\n        this._subscriptionQueue[id] = {\r\n            data,\r\n            resolve,\r\n            timeout: setTimeout(() => {\r\n                reject({\r\n                    message: \"Subscription verification timed out, this will need to be cleaned up\",\r\n                    subscriptionID: id,\r\n                });\r\n                delete this._subscriptionQueue[id];\r\n            }, 600000),\r\n        };\r\n        return this;\r\n    }\r\n\r\n    resolveSubscription(id) {\r\n        if (!this._subscriptionQueue[id]) {\r\n            return this;\r\n        }\r\n\r\n        const { resolve, timeout, data } = this._subscriptionQueue[id];\r\n        clearTimeout(timeout);\r\n        resolve(data);\r\n        delete this._subscriptionQueue[id];\r\n        return this;\r\n    }\r\n}\r\n\r\nconst instance = new EventManager();\r\nmodule.exports = instance;\r\n", "// Copyright (c) 2020-2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nmodule.exports = {\r\n    objectShallowEquals: (obj1, obj2) => {\r\n        let isEq = Object.entries(obj1).every(([key, value]) => {\r\n            if (!(key in obj2) || value !== obj2[key]) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        if (isEq) {\r\n            isEq = Object.entries(obj2).every(([key, value]) => {\r\n                if (!(key in obj1) || obj1[key] !== value) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        return isEq;\r\n    },\r\n    printObject: (obj) => {\r\n        return JSON.stringify(obj);\r\n    },\r\n};\r\n", "// Copyright (c) 2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst _browser = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\r\nconst WebSocket = _browser.WebSocket || require(\"ws\");\r\nconst EventManager = require(\"./events\");\r\nconst logger = require(\"./logger\");\r\nconst { objectShallowEquals } = require(\"./utils\");\r\n\r\nconst WS_URL = \"wss://eventsub-beta.wss.twitch.tv/ws\";\r\n\r\nclass WebSocketClient {\r\n    constructor() {\r\n        // singleton\r\n        if (WebSocketClient._instance) return WebSocketClient._instance;\r\n        WebSocketClient._instance = this;\r\n\r\n        this._connections = {};\r\n    }\r\n\r\n    /**\r\n     * Get the ID of a free WebSocket connection\r\n     *\r\n     * @returns a Promise resolving to the ID of a free WebSocket connection\r\n     */\r\n    async getFreeConnection() {\r\n        logger.debug(\"Getting free WebSocket connection\");\r\n        const connectionID = Object.keys(this._connections).find((key) => {\r\n            return Object.keys(this._connections[key].subscriptions).length < 100;\r\n        });\r\n        if (connectionID) {\r\n            logger.debug(`Found free WebSocket connection \"${connectionID}\"`);\r\n            return connectionID;\r\n        } else {\r\n            if (Object.keys(this._connections).length < 3) {\r\n                logger.debug(\"No free WebSocket connections, creating a new one...\");\r\n                return new Promise((resolve) => this._addConnection(resolve));\r\n            } else {\r\n                logger.debug(\"No free WebSocket connections, maximum number of connections reached\");\r\n                throw new Error(\"Maximum number of WebSocket connections reached\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a subscription from our connections\r\n     *\r\n     * @param {string} id the id of the subscription to remove\r\n     */\r\n    removeSubscription(id) {\r\n        // naively delete from ALL connections -- connections without that subscription will be unaffected\r\n        Object.values(this._connections).forEach((connection) => delete connection.subscriptions[id]);\r\n    }\r\n\r\n    /**\r\n     * Add a subscription to a connection\r\n     *\r\n     * @param {string} connectionID the connection id\r\n     * @param {Subscription} subscription the subscription data\r\n     */\r\n    addSubscription(connectionID, { id, type, condition }) {\r\n        this._connections[connectionID].subscriptions[id] = { type, condition };\r\n    }\r\n\r\n    /**\r\n     * Get the subscription ID for a type and condition\r\n     *\r\n     * @param {string} type the subscription type\r\n     * @param {Condition} condition the condition\r\n     */\r\n    findSubscriptionID(type, condition) {\r\n        for (const session in this._connections) {\r\n            const connection = this._connections[session];\r\n            const id = Object.keys(connection.subscriptions).find((key) => {\r\n                subscription = connection.subscriptions[key];\r\n                return subscription.type === type && objectShallowEquals(subscription.condition, condition);\r\n            });\r\n            if (id) {\r\n                return id;\r\n            }\r\n        }\r\n    }\r\n\r\n    _addConnection(onWelcome, url = WS_URL) {\r\n        const ws = new WebSocket(url);\r\n        ws.onmessage = (event) => {\r\n            const {\r\n                metadata: { message_type },\r\n                payload,\r\n            } = JSON.parse(event.data);\r\n            if (message_type === \"session_welcome\") {\r\n                const {\r\n                    session: { id, keepalive_timeout_seconds },\r\n                } = payload;\r\n                logger.debug(`Received welcome message for session \"${id}\"`);\r\n                ws.resetTimeout = () => {\r\n                    if (ws.keepaliveTimeout) {\r\n                        clearTimeout(ws.keepaliveTimeout);\r\n                    }\r\n                    ws.keepaliveTimeout = setTimeout(() => {\r\n                        EventManager.fire({ type: \"connection_lost\" }, ws.subscriptions);\r\n                        delete this._connections[id];\r\n                    }, keepalive_timeout_seconds * 1000 + 100);\r\n                };\r\n                ws.subscriptions = {};\r\n                this._connections[id] = ws;\r\n                ws.resetTimeout();\r\n                onWelcome(id);\r\n            } else if (message_type === \"session_keepalive\") {\r\n                ws.resetTimeout();\r\n            } else if (message_type === \"session_reconnect\") {\r\n                const {\r\n                    session: { id, reconnect_url },\r\n                } = payload;\r\n                logger.debug(`Received reconnect message for session \"${id}\"`);\r\n                this._addConnection(() => ws.close(), reconnect_url);\r\n            } else if (message_type === \"notification\") {\r\n                ws.resetTimeout();\r\n                const { subscription, event } = payload;\r\n                logger.log(`Received notification for type ${subscription.type}`);\r\n                EventManager.fire(subscription, event);\r\n            } else if (message_type === \"revocation\") {\r\n                ws.resetTimeout();\r\n                const { subscription } = payload;\r\n                logger.log(`Received revocation notification for subscription id ${subscription.id}`);\r\n                EventManager.fire({ ...subscription, type: \"revocation\" }, subscription);\r\n                this.removeSubscription(subscription.id);\r\n            } else {\r\n                logger.log(`Unhandled WebSocket message type \"${message_type}\"`);\r\n            }\r\n        };\r\n        ws.onclose = (event) => {\r\n            const [connectionID] = Object.entries(this._connections).find(([_id, value]) => value === ws) || [];\r\n            const { code, reason } = event;\r\n            logger.debug(`WebSocket connection \"${connectionID}\" closed. ${code}:${reason}`);\r\n            delete this._connections[connectionID];\r\n        };\r\n        return ws;\r\n    }\r\n}\r\n\r\nmodule.exports = WebSocketClient;\r\n", "// Copyright (c) 2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst _browser = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\r\nconst fetch = _browser.fetch || require(\"node-fetch\");\r\nconst logger = require(\"./logger\");\r\n\r\nconst AUTH_API_URL = \"https://id.twitch.tv/oauth2\";\r\n\r\nclass AuthManager {\r\n    constructor({ clientID, clientSecret, onAuthFailure, initialToken, refreshToken, isWebClient }) {\r\n        if (!onAuthFailure) {\r\n            if (!isWebClient && (!clientID || !clientSecret)) {\r\n                throw new Error(\"AuthManager config must contain client ID and secret if onAuthFailure not defined\");\r\n            }\r\n        }\r\n\r\n        if (AuthManager._instance) {\r\n            return AuthManager._instance;\r\n        }\r\n        AuthManager._instance = this;\r\n\r\n        this._clientID = clientID;\r\n        this._clientSecret = clientSecret;\r\n        this._isWebClient = isWebClient;\r\n\r\n        this._validationInterval;\r\n\r\n        this._customRefresh = onAuthFailure;\r\n        this._refreshToken = refreshToken;\r\n\r\n        if (initialToken) {\r\n            this._authToken = initialToken;\r\n        } else {\r\n            this.refreshToken();\r\n        }\r\n    }\r\n\r\n    static getInstance() {\r\n        return AuthManager._instance;\r\n    }\r\n\r\n    /**\r\n     * Gets the current authentication token.  This will wait until the\r\n     * auth token exists before returning.  The auth token will be undefined\r\n     * in the cases of app startup (until initial fetch/refresh) and token\r\n     * refresh.  If getting the token takes longer than 1000 seconds,\r\n     * something catastrophic is up and it will reject.\r\n     *\r\n     * @returns a promise that resolves the current token\r\n     */\r\n    getToken() {\r\n        return new Promise((resolve, reject) => {\r\n            const start = new Date();\r\n            const retry = () => {\r\n                if (this._authToken) {\r\n                    resolve(this._authToken);\r\n                } else if (new Date() - start > 1000000) {\r\n                    const message = \"Timed out trying to get token\";\r\n                    logger.error(`${message}.  Something catastrophic has happened!`);\r\n                    reject(message);\r\n                } else {\r\n                    setTimeout(retry);\r\n                }\r\n            };\r\n            retry();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Refreshes the authentication token\r\n     */\r\n    async refreshToken() {\r\n        logger.debug(\"Getting new app access token\");\r\n        try {\r\n            this._authToken = undefined; // set current token undefined to prevent API calls from using stale token\r\n            // if we have a custom refresh function passed through onAuthenticationFailure, use that\r\n            if (this._isWebClient) {\r\n                throw new Error(\"cannot refresh access token on web client\");\r\n            } else if (this._customRefresh) {\r\n                this._authToken = await this._customRefresh();\r\n            } else {\r\n                let refreshSnippet = \"\";\r\n                let grantType = \"client_credentials\";\r\n                if (this._refreshToken) {\r\n                    grantType = \"refresh_token\";\r\n                    refreshSnippet = `&refresh_token=${this._refreshToken}`;\r\n                }\r\n                const res = await fetch(\r\n                    `${AUTH_API_URL}/token?client_id=${this._clientID}&client_secret=${this._clientSecret}&grant_type=${grantType}${refreshSnippet}`,\r\n                    { method: \"POST\" }\r\n                );\r\n                if (res.ok) {\r\n                    const { access_token, refresh_token } = await res.json();\r\n                    this._authToken = access_token;\r\n                    this._refreshToken = refresh_token;\r\n                    this._resetValidationInterval();\r\n                } else {\r\n                    const { message } = await res.json();\r\n                    throw new Error(message);\r\n                }\r\n            }\r\n        } catch (err) {\r\n            logger.error(`Error refreshing app access token: ${err.message}`);\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    async _validateToken() {\r\n        logger.debug(\"Validating app access token\");\r\n        const headers = {\r\n            \"client-id\": this.clientID,\r\n            Authorization: `Bearer ${this._authToken}`,\r\n        };\r\n        const res = await fetch(`${AUTH_API_URL}/validate`, { headers });\r\n        if (res.status === 401) {\r\n            logger.debug(\"Access token not valid, refreshing...\");\r\n            this.refreshToken();\r\n        }\r\n    }\r\n\r\n    _resetValidationInterval() {\r\n        clearInterval(this._validationInterval);\r\n        this._validationInterval = setInterval(this._validateToken, 3600000);\r\n    }\r\n}\r\n\r\nmodule.exports = AuthManager;\r\n", "// Copyright (c) 2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst _browser = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\r\nconst fetch = _browser.fetch || require(\"node-fetch\");\r\nconst AuthManager = require(\"./auth\");\r\nconst logger = require(\"./logger\");\r\n\r\nclass RequestManager {\r\n    constructor() {\r\n        RequestManager._instance = this;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} url the url to fetch\r\n     * @param {object} config fetch config object\r\n     * @param {boolean} json whether or not to parse response as JSON\r\n     *                       if false, parse as text\r\n     */\r\n    async request(url, config, json = true) {\r\n        const r = async () => {\r\n            const res = await fetch(url, config);\r\n            if (res.status === 401) {\r\n                logger.debug(\"Request received 401 unauthorized response. Refreshing token and retrying...\");\r\n                const auth = AuthManager.getInstance();\r\n                try {\r\n                    await auth.refreshToken();\r\n                } catch (err) {\r\n                    if (!err.message.includes(\"web client\")) {\r\n                        throw err;\r\n                    }\r\n                    return res.json();\r\n                }\r\n                config.headers.Authorization = `Bearer ${await auth.getToken()}`;\r\n                return r();\r\n            } else {\r\n                if (json) {\r\n                    return res.json();\r\n                } else {\r\n                    return res.text();\r\n                }\r\n            }\r\n        };\r\n        return r();\r\n    }\r\n}\r\n\r\nconst instance = new RequestManager();\r\nmodule.exports = instance;\r\n", "// Copyright (c) 2020-2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst whserver = require(\"./whserver\");\r\nconst WebSocketClient = require(\"./wsclient\");\r\nconst EventManager = require(\"./events\");\r\nconst AuthManager = require(\"./auth\");\r\nconst RequestManager = require(\"./request\");\r\nconst { objectShallowEquals, printObject } = require(\"./utils\");\r\nconst logger = require(\"./logger\");\r\n\r\nconst SUBS_API_URL = \"https://api.twitch.tv/helix/eventsub/subscriptions\";\r\n\r\n/**\r\n *  Twitch EventSub\r\n */\r\nclass TES {\r\n    constructor(config) {\r\n        // TES singleton\r\n        if (TES._instance) return TES._instance;\r\n\r\n        // ensure we have an identity\r\n        if (!config.identity) throw new Error(\"TES config must contain 'identity'\");\r\n        if (!config.listener) throw new Error(\"TES config must contain 'listener'\");\r\n\r\n        const {\r\n            identity: { id, secret, onAuthenticationFailure, accessToken, refreshToken },\r\n            listener: { type, baseURL, secret: whSecret, port, ignoreDuplicateMessages, ignoreOldMessages, server },\r\n        } = config;\r\n\r\n        if (!type || (type !== \"webhook\" && type !== \"websocket\")) {\r\n            throw new Error(\"TES listener config must have 'type' either 'webhook' or 'websocket'\");\r\n        }\r\n        if (!id) throw new Error(\"TES identity config must contain 'id'\");\r\n        if (type === \"webhook\") {\r\n            if (!secret) throw new Error(\"TES identity config must contain 'secret'\");\r\n            if (!baseURL) throw new Error(\"TES listener config must contain 'baseURL'\");\r\n            if (!whSecret) throw new Error(\"TES listener config must contain 'secret'\");\r\n        } else {\r\n            if (!accessToken) throw new Error(\"TES identity config must contain 'accessToken'\");\r\n            if (typeof window === \"undefined\" && !onAuthenticationFailure && !refreshToken) {\r\n                throw new Error(\"TES identity config must contain either 'onAuthenticationFailure' or 'refreshToken'\");\r\n            }\r\n            if (refreshToken && !secret) {\r\n                throw new Error(\"TES identity config must contain 'secret'\");\r\n            }\r\n        }\r\n\r\n        TES._instance = this;\r\n\r\n        this.clientID = id;\r\n        this.transportType = type;\r\n\r\n        if (type === \"webhook\") {\r\n            this.baseURL = baseURL;\r\n            this.whSecret = whSecret;\r\n\r\n            this.port = port || process.env.PORT || 8080;\r\n            const serverConfig = {\r\n                ignoreDuplicateMessages: ignoreDuplicateMessages === false ? false : true,\r\n                ignoreOldMessages: ignoreOldMessages === false ? false : true,\r\n            };\r\n            this.whserver = whserver(server, whSecret, serverConfig);\r\n            this._whserverlistener = server ? null : this.whserver.listen(this.port);\r\n        } else {\r\n            this.wsclient = new WebSocketClient();\r\n        }\r\n\r\n        config.options = config.options || {};\r\n        config.options.debug && logger.setLevel(\"debug\");\r\n        config.options.logging === false && logger.setLevel(\"none\");\r\n\r\n        new AuthManager({\r\n            clientID: id,\r\n            clientSecret: secret,\r\n            onAuthFailure: onAuthenticationFailure,\r\n            initialToken: accessToken,\r\n            refreshToken,\r\n            isWebClient: typeof window !== \"undefined\",\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get subscriptions (with option for pagination)\r\n     *\r\n     * @param {string} cursor (optional) the pagination cursor\r\n     */\r\n    getSubscriptions(cursor) {\r\n        logger.debug(`Getting ${cursor ? `subscriptions for cursor ${cursor}` : \"first page of subscriptions\"}`);\r\n        return this._getSubs(`${SUBS_API_URL}${cursor ? `?after=${cursor}` : \"\"}`);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} type the type of the subscriptions to get\r\n     * @param {string} cursor (optional) the pagination cursor\r\n     */\r\n    getSubscriptionsByType(type, cursor) {\r\n        logger.debug(\r\n            `Getting ${cursor ? `subscriptions for cursor ${cursor}` : \"first page of subscriptions\"} of type ${type}`\r\n        );\r\n        return this._getSubs(\r\n            `${SUBS_API_URL}?${`type=${encodeURIComponent(type)}`}${cursor ? `&after=${cursor}` : \"\"}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} status the status of the subscriptions to get\r\n     * @param {string} cursor (optional) the pagination cursor\r\n     */\r\n    getSubscriptionsByStatus(status, cursor) {\r\n        logger.debug(\r\n            `Getting ${\r\n                cursor ? `subscriptions for cursor ${cursor}` : \"first page of subscriptions\"\r\n            } with status ${status}`\r\n        );\r\n        return this._getSubs(\r\n            `${SUBS_API_URL}?${`status=${encodeURIComponent(status)}`}${cursor ? `&after=${cursor}` : \"\"}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a specific condition by id or by type and condition\r\n     *\r\n     * @param  {...any} args\r\n     *      @param {string} id the id of the subscription\r\n     *      OR\r\n     *      @param {string} type the type of the subscription\r\n     *      @param {Object} condition the condition of the subscription\r\n     */\r\n    async getSubscription(...args) {\r\n        if (args.length > 2) {\r\n            throw new Error(\"getSubscription must have 1 or 2 arguments\");\r\n        }\r\n\r\n        const [idOrType, condition] = args;\r\n        if (args.length === 1) {\r\n            logger.debug(`Getting subscription for id ${idOrType}`);\r\n        } else {\r\n            logger.debug(`Getting subscription for type ${idOrType} and condition ${printObject(condition)}`);\r\n        }\r\n\r\n        let sub;\r\n        const getUntilFound = async (cursor) => {\r\n            let res;\r\n            if (args.length === 1) {\r\n                res = await this.getSubscriptions(cursor);\r\n            } else {\r\n                res = await this.getSubscriptionsByType(idOrType, cursor);\r\n            }\r\n\r\n            const { data, pagination } = res;\r\n            sub = data.find((s) => {\r\n                if (condition) {\r\n                    return s.type === idOrType && objectShallowEquals(s.condition, condition);\r\n                } else {\r\n                    return s.id === idOrType;\r\n                }\r\n            });\r\n            if (!sub && pagination.cursor) {\r\n                await getUntilFound(pagination.cursor);\r\n            }\r\n        };\r\n        await getUntilFound();\r\n        return sub;\r\n    }\r\n\r\n    /**\r\n     * Subscribe to a new event of given type and condition\r\n     *\r\n     * @param {string} type the event type\r\n     * @param {Object} condition the event condition\r\n     */\r\n    async subscribe(type, condition) {\r\n        logger.debug(`Subscribing to topic with type ${type} and condition ${printObject(condition)}`);\r\n        const token = await AuthManager.getInstance().getToken();\r\n        const headers = {\r\n            \"client-id\": this.clientID,\r\n            Authorization: `Bearer ${token}`,\r\n            \"content-type\": \"application/json\",\r\n        };\r\n        let transport = {\r\n            method: this.transportType,\r\n        };\r\n        if (this.transportType === \"webhook\") {\r\n            transport.callback = `${this.baseURL}/teswh/event`;\r\n            transport.secret = this.whSecret;\r\n        } else {\r\n            const session = await this.wsclient.getFreeConnection();\r\n            transport.session_id = session;\r\n        }\r\n        const body = {\r\n            type,\r\n            condition,\r\n            transport,\r\n            version: \"1\",\r\n        };\r\n        const data = await RequestManager.request(SUBS_API_URL, {\r\n            method: \"POST\",\r\n            body: JSON.stringify(body),\r\n            headers,\r\n        });\r\n        if (data.data) {\r\n            if (this.transportType === \"webhook\") {\r\n                return new Promise((resolve, reject) => EventManager.queueSubscription(data, resolve, reject));\r\n            } else {\r\n                const subscription = data.data[0];\r\n                this.wsclient.addSubscription(subscription.transport.session_id, subscription);\r\n                return subscription;\r\n            }\r\n        } else {\r\n            const { error, status, message } = data;\r\n            throw new Error(`${status} ${error}: ${message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from event of given id or given type and condition\r\n     *\r\n     * @param  {...any} args\r\n     *      @param {string} id the id of the subscription\r\n     *      OR\r\n     *      @param {string} type the type of the subscription\r\n     *      @param {Object} condition the condition of the subscription\r\n     */\r\n    async unsubscribe(...args) {\r\n        const token = await AuthManager.getInstance().getToken();\r\n        const headers = {\r\n            \"client-id\": this.clientID,\r\n            Authorization: `Bearer ${token}`,\r\n        };\r\n        const unsub = async (id) => {\r\n            return RequestManager.request(`${SUBS_API_URL}?id=${id}`, { method: \"DELETE\", headers }, false);\r\n        };\r\n\r\n        if (arguments.length === 1) {\r\n            const id = args[0];\r\n            logger.debug(`Unsubscribing from topic ${id}`);\r\n            return unsub(id);\r\n        } else if (arguments.length === 2) {\r\n            const [type, condition] = args;\r\n            logger.debug(`Unsubscribing from topic with type ${type} and condition ${printObject(condition)}`);\r\n            let id;\r\n            if (this.transportType === \"webhook\") {\r\n                const sub = await this.getSubscription(type, condition);\r\n                if (sub) {\r\n                    id = sub.id;\r\n                }\r\n            } else {\r\n                id = this.wsclient.findSubscriptionID(type, condition);\r\n            }\r\n            if (id) {\r\n                if (this.transportType === \"webhook\") {\r\n                    return unsub(id);\r\n                } else {\r\n                    const res = await unsub(id);\r\n                    if (res.ok) {\r\n                        this.wsclient.removeSubscription(id);\r\n                    }\r\n                    return res;\r\n                }\r\n            } else {\r\n                throw new Error(\"subscription with given type and condition not found\");\r\n            }\r\n        } else {\r\n            throw new Error(\"unsubscribe must only have 1 or 2 arguments\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Provide a callback function to respond to when event of given type is fired\r\n     *\r\n     * @param {string} type\r\n     * @param {function} callback\r\n     */\r\n    on(type, callback) {\r\n        logger.debug(`Adding notification listener for type ${type}`);\r\n        EventManager.addListener(type, callback);\r\n    }\r\n\r\n    async _getSubs(url) {\r\n        const token = await AuthManager.getInstance().getToken();\r\n        const headers = {\r\n            \"client-id\": this.clientID,\r\n            Authorization: `Bearer ${token}`,\r\n        };\r\n        return RequestManager.request(url, { headers });\r\n    }\r\n\r\n    /**\r\n     * Use this to ignore TESjs in Express middleware if they conflict and cause problems\r\n     * @param {function} middleware the middleware function to ignore TES\r\n     */\r\n    static ignoreInMiddleware(middleware) {\r\n        return (req, res, next) => {\r\n            return req.path === \"/teswh/event\" ? next() : middleware(req, res, next);\r\n        };\r\n    }\r\n}\r\n\r\nmodule.exports = TES;\r\n"],
  "mappings": "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",
  "names": ["require_whserver", "__commonJSMin", "require_logger", "__commonJSMin", "exports", "module", "levels", "level", "log", "lvl", "message", "require_events", "__commonJSMin", "exports", "module", "logger", "EventManager", "sub", "data", "handler", "type", "resolve", "reject", "id", "timeout", "instance", "require_utils", "__commonJSMin", "exports", "module", "obj1", "obj2", "isEq", "key", "value", "obj", "require_wsclient", "__commonJSMin", "exports", "module", "_browser", "WebSocket", "EventManager", "logger", "objectShallowEquals", "WS_URL", "WebSocketClient", "connectionID", "key", "resolve", "id", "connection", "type", "condition", "session", "onWelcome", "url", "ws", "event", "message_type", "payload", "keepalive_timeout_seconds", "reconnect_url", "subscription", "_id", "value", "code", "reason", "require_auth", "__commonJSMin", "exports", "module", "_browser", "fetch", "logger", "AUTH_API_URL", "AuthManager", "clientID", "clientSecret", "onAuthFailure", "initialToken", "refreshToken", "isWebClient", "resolve", "reject", "start", "retry", "message", "refreshSnippet", "grantType", "res", "access_token", "refresh_token", "err", "headers", "require_request", "__commonJSMin", "exports", "module", "_browser", "fetch", "AuthManager", "logger", "RequestManager", "url", "config", "json", "r", "res", "auth", "err", "instance", "require_tes", "__commonJSMin", "exports", "module", "whserver", "WebSocketClient", "EventManager", "AuthManager", "RequestManager", "objectShallowEquals", "printObject", "logger", "SUBS_API_URL", "TES", "config", "id", "secret", "onAuthenticationFailure", "accessToken", "refreshToken", "type", "baseURL", "whSecret", "port", "ignoreDuplicateMessages", "ignoreOldMessages", "server", "serverConfig", "cursor", "status", "args", "idOrType", "condition", "sub", "getUntilFound", "res", "data", "pagination", "s", "token", "headers", "transport", "session", "body", "resolve", "reject", "subscription", "error", "message", "unsub", "callback", "url", "middleware", "req", "next"]
}
