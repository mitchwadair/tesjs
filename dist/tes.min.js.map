{
  "version": 3,
  "sources": ["exclude-whserver:./whserver", "../lib/logger.js", "../lib/events.js", "../lib/utils.js", "../lib/wsclient.js", "../lib/auth.js", "../lib/request.js", "../lib/tes.js"],
  "sourcesContent": ["", "// Copyright (c) 2020-2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst levels = {\r\n    debug: 0,\r\n    error: 1,\r\n    warn: 2,\r\n    info: 3,\r\n    none: 4,\r\n};\r\n\r\nlet level = \"warn\";\r\n\r\nconst log = (lvl) => {\r\n    return (message) => {\r\n        if (levels[lvl] >= levels[level]) {\r\n            console.log(`${new Date().toUTCString()} - TESjs - ${message}`);\r\n        }\r\n    };\r\n};\r\n\r\nmodule.exports = {\r\n    setLevel: (lvl) => (level = lvl),\r\n    debug: log(\"debug\"),\r\n    error: log(\"error\"),\r\n    warn: log(\"warn\"),\r\n    log: log(\"info\"),\r\n};\r\n", "// Copyright (c) 2020 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst logger = require(\"./logger\");\r\n\r\nclass EventManager {\r\n    constructor() {\r\n        EventManager._instance = this;\r\n        this._events = this._events || {};\r\n        this._subscriptionQueue = this._subscriptionQueue || {};\r\n    }\r\n\r\n    fire(sub, data) {\r\n        const handler = this._events[sub.type];\r\n        if (!handler) {\r\n            logger.warn(`Recieved event for unhandled type: ${sub.type}`);\r\n            return false;\r\n        } else {\r\n            handler.call(this, data, sub);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    addListener(type, handler) {\r\n        if (typeof handler !== \"function\") {\r\n            throw TypeError(\"Event handler must be a function\");\r\n        }\r\n\r\n        this._events[type] = handler;\r\n        return this;\r\n    }\r\n\r\n    removeListener(type) {\r\n        if (this._events[type]) {\r\n            delete this._events[type];\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    removeAllListeners() {\r\n        this._events = {};\r\n        return this;\r\n    }\r\n\r\n    queueSubscription(data, resolve, reject) {\r\n        const id = data.data[0].id;\r\n        this._subscriptionQueue[id] = {\r\n            data,\r\n            resolve,\r\n            timeout: setTimeout(() => {\r\n                reject({\r\n                    message: \"Subscription verification timed out, this will need to be cleaned up\",\r\n                    subscriptionID: id,\r\n                });\r\n                delete this._subscriptionQueue[id];\r\n            }, 600000),\r\n        };\r\n        return this;\r\n    }\r\n\r\n    resolveSubscription(id) {\r\n        if (!this._subscriptionQueue[id]) {\r\n            return this;\r\n        }\r\n\r\n        const { resolve, timeout, data } = this._subscriptionQueue[id];\r\n        clearTimeout(timeout);\r\n        resolve(data);\r\n        delete this._subscriptionQueue[id];\r\n        return this;\r\n    }\r\n}\r\n\r\nconst instance = new EventManager();\r\nmodule.exports = instance;\r\n", "// Copyright (c) 2020-2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nmodule.exports = {\r\n    objectShallowEquals: (obj1, obj2) => {\r\n        let isEq = Object.entries(obj1).every(([key, value]) => {\r\n            if (!(key in obj2) || value !== obj2[key]) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        if (isEq) {\r\n            isEq = Object.entries(obj2).every(([key, value]) => {\r\n                if (!(key in obj1) || obj1[key] !== value) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        return isEq;\r\n    },\r\n    printObject: (obj) => {\r\n        return JSON.stringify(obj);\r\n    },\r\n};\r\n", "// Copyright (c) 2022-2023 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst _browser = typeof window !== \"undefined\" ? window : {};\r\nconst WebSocket = _browser.WebSocket || require(\"ws\");\r\nconst EventManager = require(\"./events\");\r\nconst logger = require(\"./logger\");\r\nconst { objectShallowEquals } = require(\"./utils\");\r\n\r\nconst WS_URL = \"wss://eventsub.wss.twitch.tv/ws\";\r\n\r\nclass WebSocketClient {\r\n    constructor(wsURL) {\r\n        // singleton\r\n        if (WebSocketClient._instance) return WebSocketClient._instance;\r\n        WebSocketClient._instance = this;\r\n\r\n        this._connections = {};\r\n\r\n        this._wsURL = wsURL || WS_URL;\r\n    }\r\n\r\n    /**\r\n     * Get the ID of a free WebSocket connection\r\n     *\r\n     * @returns a Promise resolving to the ID of a free WebSocket connection\r\n     */\r\n    async getFreeConnection() {\r\n        logger.debug(\"Getting free WebSocket connection\");\r\n        const connectionID = Object.keys(this._connections).find((key) => {\r\n            return Object.keys(this._connections[key].subscriptions).length < 300;\r\n        });\r\n        if (connectionID) {\r\n            logger.debug(`Found free WebSocket connection \"${connectionID}\"`);\r\n            return connectionID;\r\n        } else {\r\n            if (Object.keys(this._connections).length < 3) {\r\n                logger.debug(\"No free WebSocket connections, creating a new one...\");\r\n                return new Promise((resolve) => this._addConnection(resolve));\r\n            } else {\r\n                logger.debug(\"No free WebSocket connections, maximum number of connections reached\");\r\n                throw new Error(\"Maximum number of WebSocket connections reached\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a subscription from our connections\r\n     *\r\n     * @param {string} id the id of the subscription to remove\r\n     */\r\n    removeSubscription(id) {\r\n        // naively delete from ALL connections -- connections without that subscription will be unaffected\r\n        Object.values(this._connections).forEach((connection) => delete connection.subscriptions[id]);\r\n    }\r\n\r\n    /**\r\n     * Add a subscription to a connection\r\n     *\r\n     * @param {string} connectionID the connection id\r\n     * @param {Subscription} subscription the subscription data\r\n     */\r\n    addSubscription(connectionID, { id, type, condition }) {\r\n        this._connections[connectionID].subscriptions[id] = { type, condition };\r\n    }\r\n\r\n    /**\r\n     * Get the subscription ID for a type and condition\r\n     *\r\n     * @param {string} type the subscription type\r\n     * @param {Condition} condition the condition\r\n     */\r\n    findSubscriptionID(type, condition) {\r\n        for (const session in this._connections) {\r\n            const connection = this._connections[session];\r\n            const id = Object.keys(connection.subscriptions).find((key) => {\r\n                const subscription = connection.subscriptions[key];\r\n                return subscription.type === type && objectShallowEquals(subscription.condition, condition);\r\n            });\r\n            if (id) {\r\n                return id;\r\n            }\r\n        }\r\n    }\r\n\r\n    _addConnection(onWelcome, url = this._wsURL) {\r\n        const ws = new WebSocket(url);\r\n        ws.onmessage = (event) => {\r\n            const {\r\n                metadata: { message_type },\r\n                payload,\r\n            } = JSON.parse(event.data);\r\n            if (message_type === \"session_welcome\") {\r\n                const {\r\n                    session: { id, keepalive_timeout_seconds },\r\n                } = payload;\r\n                logger.debug(`Received welcome message for session \"${id}\"`);\r\n                ws.resetTimeout = () => {\r\n                    if (ws.keepaliveTimeout) {\r\n                        clearTimeout(ws.keepaliveTimeout);\r\n                    }\r\n                    ws.keepaliveTimeout = setTimeout(() => {\r\n                        EventManager.fire({ type: \"connection_lost\" }, ws.subscriptions);\r\n                        delete this._connections[id];\r\n                    }, keepalive_timeout_seconds * 1000 + 100);\r\n                };\r\n                ws.subscriptions = {};\r\n                this._connections[id] = ws;\r\n                ws.resetTimeout();\r\n                onWelcome(id);\r\n            } else if (message_type === \"session_keepalive\") {\r\n                ws.resetTimeout();\r\n            } else if (message_type === \"session_reconnect\") {\r\n                const {\r\n                    session: { id, reconnect_url },\r\n                } = payload;\r\n                logger.debug(`Received reconnect message for session \"${id}\"`);\r\n                this._addConnection(() => {\r\n                    clearTimeout(ws.keepaliveTimeout);\r\n                    ws.close();\r\n                }, reconnect_url);\r\n            } else if (message_type === \"notification\") {\r\n                ws.resetTimeout();\r\n                const { subscription, event } = payload;\r\n                logger.log(`Received notification for type ${subscription.type}`);\r\n                EventManager.fire(subscription, event);\r\n            } else if (message_type === \"revocation\") {\r\n                ws.resetTimeout();\r\n                const { subscription } = payload;\r\n                logger.log(`Received revocation notification for subscription id ${subscription.id}`);\r\n                EventManager.fire({ ...subscription, type: \"revocation\" }, subscription);\r\n                this.removeSubscription(subscription.id);\r\n            } else {\r\n                logger.log(`Unhandled WebSocket message type \"${message_type}\"`);\r\n            }\r\n        };\r\n        ws.onclose = (event) => {\r\n            const [connectionID] = Object.entries(this._connections).find(([_id, value]) => value === ws) || [];\r\n            const { code, reason } = event;\r\n            logger.debug(`WebSocket connection \"${connectionID}\" closed. ${code}:${reason}`);\r\n            delete this._connections[connectionID];\r\n        };\r\n        return ws;\r\n    }\r\n}\r\n\r\nmodule.exports = WebSocketClient;\r\n", "// Copyright (c) 2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst _browser = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\r\nconst fetch = _browser.fetch || require(\"node-fetch\");\r\nconst logger = require(\"./logger\");\r\n\r\nconst AUTH_API_URL = \"https://id.twitch.tv/oauth2\";\r\n\r\nclass AuthManager {\r\n    constructor({ clientID, clientSecret, onAuthFailure, initialToken, refreshToken }) {\r\n        this._isWebClient = typeof window !== \"undefined\";\r\n\r\n        if (!onAuthFailure) {\r\n            if (!this._isWebClient && (!clientID || !clientSecret)) {\r\n                throw new Error(\"AuthManager config must contain client ID and secret if onAuthFailure not defined\");\r\n            }\r\n        }\r\n\r\n        if (AuthManager._instance) {\r\n            return AuthManager._instance;\r\n        }\r\n        AuthManager._instance = this;\r\n\r\n        this._clientID = clientID;\r\n        this._clientSecret = clientSecret;\r\n\r\n        this._validationInterval;\r\n\r\n        this._customRefresh = onAuthFailure;\r\n        this._refreshToken = refreshToken;\r\n\r\n        if (initialToken) {\r\n            this._authToken = initialToken;\r\n            this._resetValidationInterval();\r\n        } else {\r\n            this.refreshToken();\r\n        }\r\n    }\r\n\r\n    static getInstance() {\r\n        return AuthManager._instance;\r\n    }\r\n\r\n    /**\r\n     * Gets the current authentication token.  This will wait until the\r\n     * auth token exists before returning.  The auth token will be undefined\r\n     * in the cases of app startup (until initial fetch/refresh) and token\r\n     * refresh.  If getting the token takes longer than 1000 seconds,\r\n     * something catastrophic is up and it will reject.\r\n     *\r\n     * @returns a promise that resolves the current token\r\n     */\r\n    getToken() {\r\n        return new Promise((resolve, reject) => {\r\n            const start = new Date();\r\n            const retry = () => {\r\n                if (this._authToken) {\r\n                    resolve(this._authToken);\r\n                } else if (new Date() - start > 1000000) {\r\n                    const message = \"Timed out trying to get token\";\r\n                    logger.error(`${message}.  Something catastrophic has happened!`);\r\n                    reject(message);\r\n                } else {\r\n                    setTimeout(retry);\r\n                }\r\n            };\r\n            retry();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Refreshes the authentication token\r\n     */\r\n    async refreshToken() {\r\n        logger.debug(\"Getting new app access token\");\r\n        try {\r\n            this._authToken = undefined; // set current token undefined to prevent API calls from using stale token\r\n            // if we have a custom refresh function passed through onAuthenticationFailure, we will use that\r\n            if (this._customRefresh) {\r\n                // Support webclients that have custom refreshes (must have a phone home server)\r\n                // we want to wait for this function to finish executing before continuing\r\n                // as if a getToken is executing near the same time, this._authToken will be the value of a promise wrapper\r\n                // and thus getToken will resolve improperly.\r\n                const tempTokenSave = await this._customRefresh();\r\n                this._authToken = tempTokenSave;\r\n            } else if (this._isWebClient) {\r\n                // If a custom refresh is not provided, throw an error.\r\n                throw new Error(\"cannot refresh access token on web client\");\r\n            } else {\r\n                let refreshSnippet = \"\";\r\n                let grantType = \"client_credentials\";\r\n                if (this._refreshToken) {\r\n                    grantType = \"refresh_token\";\r\n                    refreshSnippet = `&refresh_token=${this._refreshToken}`;\r\n                }\r\n                const res = await fetch(\r\n                    `${AUTH_API_URL}/token?client_id=${this._clientID}&client_secret=${this._clientSecret}&grant_type=${grantType}${refreshSnippet}`,\r\n                    { method: \"POST\" }\r\n                );\r\n                if (res.ok) {\r\n                    const { access_token, refresh_token } = await res.json();\r\n                    this._authToken = access_token;\r\n                    this._refreshToken = refresh_token;\r\n                    this._resetValidationInterval();\r\n                } else {\r\n                    const { message } = await res.json();\r\n                    throw new Error(message);\r\n                }\r\n            }\r\n        } catch (err) {\r\n            logger.error(`Error refreshing app access token: ${err.message}`);\r\n            throw err;\r\n        }\r\n    }\r\n\r\n    async _validateToken() {\r\n        logger.debug(\"Validating app access token\");\r\n        const headers = {\r\n            Authorization: `Bearer ${this._authToken}`,\r\n        };\r\n        const res = await fetch(`${AUTH_API_URL}/validate`, { headers });\r\n        if (res.status === 401) {\r\n            logger.debug(\"Access token not valid, refreshing...\");\r\n            this.refreshToken();\r\n        }\r\n    }\r\n\r\n    _resetValidationInterval() {\r\n        clearInterval(this._validationInterval);\r\n        if (!this._isWebClient) {\r\n            this._validationInterval = setInterval(this._validateToken.bind(this), 3600000);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = AuthManager;\r\n", "// Copyright (c) 2022 Mitchell Adair\r\n//\r\n// This software is released under the MIT License.\r\n// https://opensource.org/licenses/MIT\r\n\r\nconst _browser = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\r\nconst fetch = _browser.fetch || require(\"node-fetch\");\r\nconst AuthManager = require(\"./auth\");\r\nconst logger = require(\"./logger\");\r\n\r\nclass RequestManager {\r\n    constructor() {\r\n        RequestManager._instance = this;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {string} url the url to fetch\r\n     * @param {object} config fetch config object\r\n     * @param {boolean} json whether or not to parse response as JSON\r\n     *                       if false, parse as text\r\n     */\r\n    async request(url, config, json = true) {\r\n        const r = async () => {\r\n            const res = await fetch(url, config);\r\n            if (res.status === 401) {\r\n                logger.debug(\"Request received 401 unauthorized response. Refreshing token and retrying...\");\r\n                const auth = AuthManager.getInstance();\r\n                try {\r\n                    await auth.refreshToken();\r\n                } catch (err) {\r\n                    if (!err.message.includes(\"web client\")) {\r\n                        throw err;\r\n                    }\r\n                    return res.json();\r\n                }\r\n                config.headers.Authorization = `Bearer ${await auth.getToken()}`;\r\n                return r();\r\n            } else {\r\n                if (json) {\r\n                    return res.json();\r\n                } else {\r\n                    return res.text();\r\n                }\r\n            }\r\n        };\r\n        return r();\r\n    }\r\n}\r\n\r\nconst instance = new RequestManager();\r\nmodule.exports = instance;\r\n", "const whserver = require(\"./whserver\");\r\nconst WebSocketClient = require(\"./wsclient\");\r\nconst EventManager = require(\"./events\");\r\nconst AuthManager = require(\"./auth\");\r\nconst RequestManager = require(\"./request\");\r\nconst { objectShallowEquals, printObject } = require(\"./utils\");\r\nconst logger = require(\"./logger\");\r\n\r\nconst SUBS_API_URL = \"https://api.twitch.tv/helix/eventsub/subscriptions\";\r\n\r\n/**\r\n * @typedef {Object} TES~Config\r\n * @param {TES~Config~Options} [options] Basic configuration options\r\n * @param {TES~Config~Identity} identity Identity information\r\n * @param {TES~Config~Listener} listener Your notification listener details\r\n */\r\n\r\n/**\r\n * Basic configuration options\r\n *\r\n * @typedef {Object} TES~Config~Options\r\n * @param {boolean} [debug=false] Set to true for in-depth logging\r\n * @param {boolean} [logging=true] Set to false for no logging\r\n */\r\n\r\n/**\r\n * Identity configuration\r\n *\r\n * @typedef {Object} TES~Config~Identity\r\n * @param {string} id Your client ID\r\n * @param {string} [secret] Your client secret, required for webhook transport or\r\n *     when not using `onAuthenticationFailure` in server-side `websocket` applications\r\n * @param {TES~Config~Identity~onAuthenticationFailure} [onAuthenticationFailure] Callback function called\r\n *     when API requests get an auth failure. If you already have an authentication solution for your app\r\n *     elsewhere use this to avoid token conflicts\r\n * @param {string} [accessToken] If you already have an access token, put it here. Must\r\n *     be user access token for `websocket` transport, must be app access token for `webhook` transport.  Should\r\n *     usually be paired with `onAuthenticationFailure` on server-side applications\r\n * @param {string} [refreshToken] The refresh token to use if using `websocket` transport\r\n *     server-side. Required when not using `onAuthenticationFailure` in server-side `websocket` applications\r\n */\r\n\r\n/**\r\n * Callback function called when API requests get an auth failure. If you already have an authentication solution\r\n * for your app elsewhere use this to avoid token conflicts\r\n *\r\n * @callback TES~Config~Identity~onAuthenticationFailure\r\n * @returns {Promise} Promise that resolves a new access token\r\n * @example\r\n * ```js\r\n * async function onAuthenticationFailure() {\r\n *     const res = await getNewAccessToken(); // your token refresh logic\r\n *     return res.access_token;\r\n * }\r\n * ```\r\n */\r\n\r\n/**\r\n * Listener configuration\r\n *\r\n * @typedef {Object} TES~Config~Listener\r\n * @param {\"webhook\"|\"websocket\"} type The type of transport to use\r\n * @param {string} [baseURL] Required for `webhook` transport. The base URL where your app is\r\n *     hosted. See [Twitch doc](https://dev.twitch.tv/docs/eventsub) for details on local development\r\n * @param {string} [websocketURL=wss://eventsub.wss.twitch.tv/ws] A custom websocket URL to use for `websocket` transport. Useful for\r\n *     local testing with [Twitch CLI](https://dev.twitch.tv/docs/cli/)\r\n * @param {string} [secret] Required for `webhook` transport. The secret to use for your `webhook`\r\n *     subscriptions. Should be different from your client secret\r\n * @param {Express} [server] The Express app object. Use if integrating with an existing Express app\r\n * @param {number} [port=process.env.PORT,8080] A custom port to use\r\n * @param {boolean} [ignoreDuplicateMessages=true] Ignore event messages with IDs that have already\r\n *     been seen. Only used in `webhook` transport\r\n * @param {boolean} [ignoreOldMessages=true] Ignore event messages with timestamps older than ten\r\n *     minutes. Only used in `webhook` transport\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright (c) 2020-2023 Mitchell Adair\r\n *\r\n * This software is released under the MIT License.\r\n * https://opensource.org/licenses/MIT\r\n */\r\nclass TES {\r\n    /**\r\n     * @typicalname tes\r\n     * @param {TES~Config} config The TES configuration\r\n     * @returns {TES} The TESjs instance\r\n     * @example\r\n     * Minimum `websocket` config\r\n     * ```js\r\n     * const config = {\r\n     *     identity: {\r\n     *         id: YOUR_CLIENT_ID,\r\n     *         accessToken: YOUR_USER_ACCESS_TOKEN,\r\n     *     }\r\n     *     listener: { type: \"websocket\" },\r\n     * };\r\n     * const tes = new TES(config);\r\n     * ```\r\n     * @example\r\n     * Minimum `webhook` config\r\n     * ```js\r\n     * const config = {\r\n     *     identity: {\r\n     *         id: YOUR_CLIENT_ID,\r\n     *         secret: YOUR_CLIENT_SECRET,\r\n     *     },\r\n     *     listener: {\r\n     *         type: \"webhook\",\r\n     *         baseURL: \"https://example.com\",\r\n     *         secret: YOUR_WEBHOOKS_SECRET,\r\n     *     },\r\n     * };\r\n     * const tes = new TES(config);\r\n     * ```\r\n     */\r\n    constructor(config) {\r\n        // TES singleton\r\n        if (TES._instance) return TES._instance;\r\n\r\n        // ensure we have an identity\r\n        if (!config.identity) throw new Error(\"TES config must contain 'identity'\");\r\n        if (!config.listener) throw new Error(\"TES config must contain 'listener'\");\r\n\r\n        const {\r\n            identity: { id, secret, onAuthenticationFailure, accessToken, refreshToken },\r\n            listener: {\r\n                type,\r\n                baseURL,\r\n                secret: whSecret,\r\n                port,\r\n                ignoreDuplicateMessages,\r\n                ignoreOldMessages,\r\n                server,\r\n                websocketURL,\r\n            },\r\n        } = config;\r\n\r\n        if (!type || (type !== \"webhook\" && type !== \"websocket\")) {\r\n            throw new Error(\"TES listener config must have 'type' either 'webhook' or 'websocket'\");\r\n        }\r\n        if (!id) throw new Error(\"TES identity config must contain 'id'\");\r\n        if (type === \"webhook\") {\r\n            if (!secret) throw new Error(\"TES identity config must contain 'secret'\");\r\n            if (!baseURL) throw new Error(\"TES listener config must contain 'baseURL'\");\r\n            if (!whSecret) throw new Error(\"TES listener config must contain 'secret'\");\r\n        } else {\r\n            if (!accessToken) throw new Error(\"TES identity config must contain 'accessToken'\");\r\n            if (typeof window === \"undefined\" && !onAuthenticationFailure && !refreshToken) {\r\n                throw new Error(\"TES identity config must contain either 'onAuthenticationFailure' or 'refreshToken'\");\r\n            }\r\n            if (refreshToken && !secret) {\r\n                throw new Error(\"TES identity config must contain 'secret'\");\r\n            }\r\n        }\r\n\r\n        TES._instance = this;\r\n\r\n        this.clientID = id;\r\n        this.transportType = type;\r\n\r\n        if (type === \"webhook\") {\r\n            this.baseURL = baseURL;\r\n            this.whSecret = whSecret;\r\n\r\n            this.port = port || process.env.PORT || 8080;\r\n            const serverConfig = {\r\n                ignoreDuplicateMessages: ignoreDuplicateMessages === false ? false : true,\r\n                ignoreOldMessages: ignoreOldMessages === false ? false : true,\r\n            };\r\n            this.whserver = whserver(server, whSecret, serverConfig);\r\n            this._whserverlistener = server ? null : this.whserver.listen(this.port);\r\n        } else {\r\n            this.wsclient = new WebSocketClient(websocketURL);\r\n        }\r\n\r\n        config.options = config.options || {};\r\n        config.options.debug && logger.setLevel(\"debug\");\r\n        config.options.logging === false && logger.setLevel(\"none\");\r\n\r\n        new AuthManager({\r\n            clientID: id,\r\n            clientSecret: secret,\r\n            onAuthFailure: onAuthenticationFailure,\r\n            initialToken: accessToken,\r\n            refreshToken,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get a list of your event subscriptions\r\n     *\r\n     * @param {string} [cursor] The pagination cursor\r\n     * @returns {Promise} Subscription data. See [Twitch doc](https://dev.twitch.tv/docs/api/reference/#get-eventsub-subscriptions) for details\r\n     * @example\r\n     * ```js\r\n     * const subs = await tes.getSubscriptions();\r\n     * console.log(`I have ${subs.total} event subscriptions`);\r\n     * ```\r\n     */\r\n    getSubscriptions(cursor) {\r\n        logger.debug(`Getting ${cursor ? `subscriptions for cursor ${cursor}` : \"first page of subscriptions\"}`);\r\n        return this._getSubs(`${SUBS_API_URL}${cursor ? `?after=${cursor}` : \"\"}`);\r\n    }\r\n\r\n    /**\r\n     * Get a list of your event subscriptions by type\r\n     *\r\n     * @param {string} type The type of subscription. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#subscription-types) for details\r\n     * @param {string} [cursor] The pagination cursor\r\n     * @returns {Promise} Subscription data. See [Twitch doc](https://dev.twitch.tv/docs/api/reference/#get-eventsub-subscriptions) for details\r\n     * @example\r\n     * ```js\r\n     * const subs = await tes.getSubscriptionsByType(\"channel.update\");\r\n     * console.log(`I have ${subs.total} \"channel.update\" event subscriptions`);\r\n     * ```\r\n     */\r\n    getSubscriptionsByType(type, cursor) {\r\n        logger.debug(\r\n            `Getting ${cursor ? `subscriptions for cursor ${cursor}` : \"first page of subscriptions\"} of type ${type}`\r\n        );\r\n        return this._getSubs(\r\n            `${SUBS_API_URL}?${`type=${encodeURIComponent(type)}`}${cursor ? `&after=${cursor}` : \"\"}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get a list of your event subscriptions by status\r\n     *\r\n     * @param {string} status The subscription status. See [Twitch doc](https://dev.twitch.tv/docs/api/reference/#get-eventsub-subscriptions) for details\r\n     * @param {string} [cursor] The pagination cursor\r\n     * @returns {Promise} Subscription data. See [Twitch doc](https://dev.twitch.tv/docs/api/reference/#get-eventsub-subscriptions) for details\r\n     * @example\r\n     * ```js\r\n     * const subs = await tes.getSubscriptionsByStatus(\"enabled\");\r\n     * console.log(`I have ${subs.total} \"enabled\" event subscriptions`);\r\n     * ```\r\n     */\r\n    getSubscriptionsByStatus(status, cursor) {\r\n        logger.debug(\r\n            `Getting ${\r\n                cursor ? `subscriptions for cursor ${cursor}` : \"first page of subscriptions\"\r\n            } with status ${status}`\r\n        );\r\n        return this._getSubs(\r\n            `${SUBS_API_URL}?${`status=${encodeURIComponent(status)}`}${cursor ? `&after=${cursor}` : \"\"}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get subscription data for an individual subscription. Search either by id or by type and condition\r\n     *\r\n     * @signature `getSubscription(id)`\r\n     * @signature `getSubscription(type, condition)`\r\n     * @param {string} idOrType The subscription id or [type](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#subscription-types)\r\n     * @param {Object} [condition] The subscription condition, required when finding by type. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-reference/#conditions) for details\r\n     * @returns {Promise} The subscription data\r\n     * @example\r\n     * Find a subscription by id\r\n     * ```js\r\n     * const sub = await tes.getSubscription(\"2d9e9f1f-39c3-426d-88f5-9f0251c9bfef\");\r\n     * console.log(`The status for subscription ${sub.id} is ${sub.status}`);\r\n     * ```\r\n     * @example\r\n     * Find a subscription by type and condition\r\n     * ```js\r\n     * const condition = { broadcaster_user_id: \"1337\" };\r\n     * const sub = await tes.getSubscription(\"channel.update\", condition);\r\n     * console.log(`The status for subscription ${sub.id} is ${sub.status}`);\r\n     * ```\r\n     */\r\n    async getSubscription(idOrType, condition) {\r\n        if (condition) {\r\n            logger.debug(`Getting subscription for type ${idOrType} and condition ${printObject(condition)}`);\r\n        } else {\r\n            logger.debug(`Getting subscription for id ${idOrType}`);\r\n        }\r\n\r\n        let sub;\r\n        const getUntilFound = async (cursor) => {\r\n            let res;\r\n            if (condition) {\r\n                res = await this.getSubscriptionsByType(idOrType, cursor);\r\n            } else {\r\n                res = await this.getSubscriptions(cursor);\r\n            }\r\n\r\n            const { data, pagination } = res;\r\n            sub = data.find((s) => {\r\n                if (condition) {\r\n                    return s.type === idOrType && objectShallowEquals(s.condition, condition);\r\n                } else {\r\n                    return s.id === idOrType;\r\n                }\r\n            });\r\n            if (!sub && pagination.cursor) {\r\n                await getUntilFound(pagination.cursor);\r\n            }\r\n        };\r\n        await getUntilFound();\r\n        return sub;\r\n    }\r\n\r\n    /**\r\n     * Subscribe to an event\r\n     *\r\n     * @param {string} type The subscription type. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#subscription-types) for details\r\n     * @param {Object} condition The subscription condition. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-reference/#conditions) for details\r\n     * @param {string} [version] The subscription version. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#subscription-types) for details\r\n     * @returns {Promise} A Promise that resolves when subscribing is complete with the subscription data\r\n     * @example\r\n     * ```js\r\n     * const condition = { broadcaster_user_id: \"1337\" };\r\n     * const sub = tes.subscribe(\"channel.update\", condition);\r\n     * console.log(`Created subscription to ${sub.type}, subscription id ${sub.id}`);\r\n     * ```\r\n     */\r\n    async subscribe(type, condition, version = \"1\") {\r\n        logger.debug(`Subscribing to topic with type ${type} and condition ${printObject(condition)}`);\r\n        const token = await AuthManager.getInstance().getToken();\r\n        const headers = {\r\n            \"client-id\": this.clientID,\r\n            Authorization: `Bearer ${token}`,\r\n            \"content-type\": \"application/json\",\r\n        };\r\n        let transport = {\r\n            method: this.transportType,\r\n        };\r\n        if (this.transportType === \"webhook\") {\r\n            transport.callback = `${this.baseURL}/teswh/event`;\r\n            transport.secret = this.whSecret;\r\n        } else {\r\n            const session = await this.wsclient.getFreeConnection();\r\n            transport.session_id = session;\r\n        }\r\n        const body = {\r\n            type,\r\n            condition,\r\n            transport,\r\n            version,\r\n        };\r\n        const data = await RequestManager.request(SUBS_API_URL, {\r\n            method: \"POST\",\r\n            body: JSON.stringify(body),\r\n            headers,\r\n        });\r\n        if (data.data) {\r\n            if (this.transportType === \"webhook\") {\r\n                return new Promise((resolve, reject) => EventManager.queueSubscription(data, resolve, reject));\r\n            } else {\r\n                const subscription = data.data[0];\r\n                this.wsclient.addSubscription(subscription.transport.session_id, subscription);\r\n                return subscription;\r\n            }\r\n        } else {\r\n            const { error, status, message } = data;\r\n            throw new Error(`${status} ${error}: ${message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from an event. Unsubscribe either by id, or by type and condition\r\n     *\r\n     * @signature `unsubscribe(id)`\r\n     * @signature `unsubscribe(type, condition)`\r\n     * @param {string} idOrType The subscription id or [type](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#subscription-types)\r\n     * @param {Object} [condition] The subscription condition, required when finding by type. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-reference/#conditions) for details\r\n     * @returns {Promise} Resolves when unsubscribed\r\n     * @example\r\n     * Unsubscribe by id\r\n     * ```js\r\n     * await tes.unsubscribe(\"2d9e9f1f-39c3-426d-88f5-9f0251c9bfef\");\r\n     * console.log(\"Successfully unsubscribed\");\r\n     * ```\r\n     * @example\r\n     * Unsubscribe by type and condition\r\n     * ```js\r\n     * const condition = { broadcaster_user_id: \"1337\" };\r\n     * await tes.unsubscribe(\"channel.update\", condition);\r\n     * console.log(\"Successfully unsubscribed\");\r\n     * ```\r\n     */\r\n    async unsubscribe(idOrType, condition) {\r\n        const token = await AuthManager.getInstance().getToken();\r\n        const headers = {\r\n            \"client-id\": this.clientID,\r\n            Authorization: `Bearer ${token}`,\r\n        };\r\n        const unsub = async (id) => {\r\n            return RequestManager.request(`${SUBS_API_URL}?id=${id}`, { method: \"DELETE\", headers }, false);\r\n        };\r\n\r\n        if (condition) {\r\n            logger.debug(`Unsubscribing from topic with type ${idOrType} and condition ${printObject(condition)}`);\r\n            let id;\r\n            if (this.transportType === \"webhook\") {\r\n                const sub = await this.getSubscription(idOrType, condition);\r\n                if (sub) {\r\n                    id = sub.id;\r\n                }\r\n            } else {\r\n                id = this.wsclient.findSubscriptionID(idOrType, condition);\r\n            }\r\n            if (id) {\r\n                if (this.transportType === \"webhook\") {\r\n                    return unsub(id);\r\n                } else {\r\n                    const res = await unsub(id);\r\n                    if (res.ok) {\r\n                        this.wsclient.removeSubscription(id);\r\n                    }\r\n                    return res;\r\n                }\r\n            } else {\r\n                throw new Error(\"subscription with given type and condition not found\");\r\n            }\r\n        } else {\r\n            logger.debug(`Unsubscribing from topic ${idOrType}`);\r\n            return unsub(idOrType);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when an event TES is listening for is triggered. See [TES.on](#TES+on) for examples\r\n     *\r\n     * @callback TES~onEventCallback\r\n     * @param {Object} [event] The event data. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-reference/#events) for details.\r\n     *     See the [TES.on](#TES+on) examples for details on `revocation` and `connection_lost`\r\n     * @param {Object} [subscription] The subscription data corresponding to the event. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-reference/#subscription) for details\r\n     * @returns {void}\r\n     */\r\n\r\n    /**\r\n     * Add an event handler. This will handle ALL events of the type\r\n     *\r\n     * @param {string|\"revocation\"|\"connection_lost\"} type The subscription type. See [Twitch doc](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#subscription-types) for details.\r\n     *     See the examples for details on `revocation` and `connection_lost`\r\n     * @param {TES~onEventCallback} callback The function to call when the event happens\r\n     * @returns {void}\r\n     * @example\r\n     * ```js\r\n     * tes.on(\"channel.update\", (event, subscription) => {\r\n     *     console.log(`Event triggered for subscription ${subscription.id}`);\r\n     *     console.log(`${event.broadcaster_user_id}'s title is now \"${event.title}\"`);\r\n     * });\r\n     * ```\r\n     * @example\r\n     * The `revocation` event is fired when Twitch revokes a subscription. This can happen\r\n     * for various reasons [according to Twitch](https://dev.twitch.tv/docs/eventsub/handling-webhook-events/#revoking-your-subscription).\r\n     * The \"event\" argument is the subscription data. This means that for this, the first and second arguments are basically identical\r\n     *\r\n     * **NOTE**: No explicit subscription is needed for this event to be fired\r\n     * ```js\r\n     * tes.on(\"revocation\", (subscriptionData) => {\r\n     *     console.log(`Subscription ${subscriptionData.id} has been revoked`);\r\n     *     // perform necessary cleanup here\r\n     * });\r\n     * ```\r\n     * @example\r\n     * The `connection_lost` event is fired when a WebSocket connection is lost. All related\r\n     * subscriptions should be considered stale if this happens. You can read more about this case\r\n     * in the [Twitch doc](https://dev.twitch.tv/docs/eventsub/handling-websocket-events/#keepalive-message).\r\n     * The \"event\" argument is an `Object` which has subscription ids as keys and type and condition as the values\r\n     *\r\n     * **NOTE**: No explicit subscription is needed for this event to be fired\r\n     * ```js\r\n     * tes.on(\"connection_lost\", (subscriptions) => {\r\n     *     // if your subscriptions are important to you, resubscribe to them\r\n     *     Object.values(subscriptions).forEach((subscription) => {\r\n     *         tes.subscribe(subscription.type, subscription.condition);\r\n     *     });\r\n     * });\r\n     * ```\r\n     */\r\n    on(type, callback) {\r\n        logger.debug(`Adding notification listener for type ${type}`);\r\n        EventManager.addListener(type, callback);\r\n    }\r\n\r\n    async _getSubs(url) {\r\n        const token = await AuthManager.getInstance().getToken();\r\n        const headers = {\r\n            \"client-id\": this.clientID,\r\n            Authorization: `Bearer ${token}`,\r\n        };\r\n        return RequestManager.request(url, { headers });\r\n    }\r\n\r\n    static ignoreInMiddleware(middleware) {\r\n        return (req, res, next) => {\r\n            return req.path === \"/teswh/event\" ? next() : middleware(req, res, next);\r\n        };\r\n    }\r\n}\r\n\r\nmodule.exports = TES;\r\n"],
  "mappings": "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",
  "names": ["require_whserver", "__commonJSMin", "require_logger", "__commonJSMin", "exports", "module", "levels", "level", "log", "lvl", "message", "require_events", "__commonJSMin", "exports", "module", "logger", "EventManager", "sub", "data", "handler", "type", "resolve", "reject", "id", "timeout", "instance", "require_utils", "__commonJSMin", "exports", "module", "obj1", "obj2", "isEq", "key", "value", "obj", "require_wsclient", "__commonJSMin", "exports", "module", "_browser", "WebSocket", "EventManager", "logger", "objectShallowEquals", "WS_URL", "WebSocketClient", "wsURL", "connectionID", "key", "resolve", "id", "connection", "type", "condition", "session", "subscription", "onWelcome", "url", "ws", "event", "message_type", "payload", "keepalive_timeout_seconds", "reconnect_url", "_id", "value", "code", "reason", "require_auth", "__commonJSMin", "exports", "module", "_browser", "fetch", "logger", "AUTH_API_URL", "AuthManager", "clientID", "clientSecret", "onAuthFailure", "initialToken", "refreshToken", "resolve", "reject", "start", "retry", "message", "tempTokenSave", "refreshSnippet", "grantType", "res", "access_token", "refresh_token", "err", "headers", "require_request", "__commonJSMin", "exports", "module", "_browser", "fetch", "AuthManager", "logger", "RequestManager", "url", "config", "json", "r", "res", "auth", "err", "instance", "require_tes", "__commonJSMin", "exports", "module", "whserver", "WebSocketClient", "EventManager", "AuthManager", "RequestManager", "objectShallowEquals", "printObject", "logger", "SUBS_API_URL", "TES", "config", "id", "secret", "onAuthenticationFailure", "accessToken", "refreshToken", "type", "baseURL", "whSecret", "port", "ignoreDuplicateMessages", "ignoreOldMessages", "server", "websocketURL", "serverConfig", "cursor", "status", "idOrType", "condition", "sub", "getUntilFound", "res", "data", "pagination", "s", "version", "token", "headers", "transport", "session", "body", "resolve", "reject", "subscription", "error", "message", "unsub", "callback", "url", "middleware", "req", "next"]
}
