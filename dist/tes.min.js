var TES=(()=>{var S=(u=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(u,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):u)(function(u){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+u+'" is not supported')});var f=(u,e)=>()=>(e||u((e={exports:{}}).exports,e),e.exports);var j=f(()=>{});var w=f((we,x)=>{var A={debug:0,error:1,warn:2,info:3,none:4},W="warn",y=u=>e=>{A[u]>=A[W]&&console.log(`${new Date().toUTCString()} - TESjs - ${e}`)};x.exports={setLevel:u=>W=u,debug:y("debug"),error:y("error"),warn:y("warn"),log:y("info")}});var E=f((ge,C)=>{var X=w(),_=class{constructor(){_._instance=this,this._events=this._events||{},this._subscriptionQueue=this._subscriptionQueue||{}}fire(e,t){let s=this._events[e.type];return s?(s.call(this,t,e),!0):(X.warn(`Recieved event for unhandled type: ${e.type}`),!1)}addListener(e,t){if(typeof t!="function")throw TypeError("Event handler must be a function");return this._events[e]=t,this}removeListener(e){return this._events[e]&&delete this._events[e],this}removeAllListeners(){return this._events={},this}queueSubscription(e,t,s){let n=e.data[0].id;return this._subscriptionQueue[n]={data:e,resolve:t,timeout:setTimeout(()=>{s({message:"Subscription verification timed out, this will need to be cleaned up",subscriptionID:n}),delete this._subscriptionQueue[n]},6e5)},this}resolveSubscription(e){if(!this._subscriptionQueue[e])return this;let{resolve:t,timeout:s,data:n}=this._subscriptionQueue[e];return clearTimeout(s),t(n),delete this._subscriptionQueue[e],this}},Y=new _;C.exports=Y});var I=f((_e,O)=>{O.exports={objectShallowEquals:(u,e)=>{let t=Object.entries(u).every(([s,n])=>!(!(s in e)||n!==e[s]));return t&&(t=Object.entries(e).every(([s,n])=>!(!(s in u)||u[s]!==n))),t},printObject:u=>JSON.stringify(u)}});var P=f((me,B)=>{var Z=typeof window<"u"?window:{},ee=Z.WebSocket||S("../node_modules/ws/browser.js"),q=E(),l=w(),{objectShallowEquals:te}=I(),se="wss://eventsub.wss.twitch.tv/ws",b=class{constructor(e){if(b._instance)return b._instance;b._instance=this,this._connections={},this._wsURL=e||se}async getFreeConnection(){l.debug("Getting free WebSocket connection");let e=Object.keys(this._connections).find(t=>Object.keys(this._connections[t].subscriptions).length<300);if(e)return l.debug(`Found free WebSocket connection "${e}"`),e;if(Object.keys(this._connections).length<3)return l.debug("No free WebSocket connections, creating a new one..."),new Promise(t=>this._addConnection(t));throw l.debug("No free WebSocket connections, maximum number of connections reached"),new Error("Maximum number of WebSocket connections reached")}removeSubscription(e){Object.values(this._connections).forEach(t=>delete t.subscriptions[e])}addSubscription(e,{id:t,type:s,condition:n}){this._connections[e].subscriptions[t]={type:s,condition:n}}findSubscriptionID(e,t){for(let s in this._connections){let n=this._connections[s],o=Object.keys(n.subscriptions).find(r=>{let i=n.subscriptions[r];return i.type===e&&te(i.condition,t)});if(o)return o}}_addConnection(e,t=this._wsURL){let s=new ee(t);return s.onmessage=n=>{let{metadata:{message_type:o},payload:r}=JSON.parse(n.data);if(o==="session_welcome"){let{session:{id:i,keepalive_timeout_seconds:a}}=r;l.debug(`Received welcome message for session "${i}"`),s.resetTimeout=()=>{s.keepaliveTimeout&&clearTimeout(s.keepaliveTimeout),s.keepaliveTimeout=setTimeout(()=>{q.fire({type:"connection_lost"},s.subscriptions),delete this._connections[i]},a*1e3+100)},s.subscriptions={},this._connections[i]=s,s.resetTimeout(),e(i)}else if(o==="session_keepalive")s.resetTimeout();else if(o==="session_reconnect"){let{session:{id:i,reconnect_url:a}}=r;l.debug(`Received reconnect message for session "${i}"`),this._addConnection(()=>{clearTimeout(s.keepaliveTimeout),s.close()},a)}else if(o==="notification"){s.resetTimeout();let{subscription:i,event:a}=r;l.log(`Received notification for type ${i.type}`),q.fire(i,a)}else if(o==="revocation"){s.resetTimeout();let{subscription:i}=r;l.log(`Received revocation notification for subscription id ${i.id}`),q.fire({...i,type:"revocation"},i),this.removeSubscription(i.id)}else l.log(`Unhandled WebSocket message type "${o}"`)},s.onclose=n=>{let[o]=Object.entries(this._connections).find(([a,c])=>c===s)||[],{code:r,reason:i}=n;l.debug(`WebSocket connection "${o}" closed. ${r}:${i}`),delete this._connections[o]},s}};B.exports=b});var R=f((ve,Q)=>{var ne=typeof global<"u"?global:typeof window<"u"?window:{},F=ne.fetch||S("../node_modules/node-fetch/browser.js"),m=w(),G="https://id.twitch.tv/oauth2",d=class{constructor({clientID:e,clientSecret:t,onAuthFailure:s,initialToken:n,refreshToken:o}){if(this._isWebClient=typeof window<"u",!s&&!this._isWebClient&&(!e||!t))throw new Error("AuthManager config must contain client ID and secret if onAuthFailure not defined");if(d._instance)return d._instance;d._instance=this,this._clientID=e,this._clientSecret=t,this._validationInterval,this._customRefresh=s,this._refreshToken=o,n?(this._authToken=n,this._resetValidationInterval()):this.refreshToken()}static getInstance(){return d._instance}getToken(){return new Promise((e,t)=>{let s=new Date,n=()=>{if(this._authToken)e(this._authToken);else if(new Date-s>1e6){let o="Timed out trying to get token";m.error(`${o}.  Something catastrophic has happened!`),t(o)}else setTimeout(n)};n()})}async refreshToken(){m.debug("Getting new app access token");try{if(this._authToken=void 0,this._customRefresh){let e=await this._customRefresh();this._authToken=e}else{if(this._isWebClient)throw new Error("cannot refresh access token on web client");{let e="",t="client_credentials";this._refreshToken&&(t="refresh_token",e=`&refresh_token=${this._refreshToken}`);let s=await F(`${G}/token?client_id=${this._clientID}&client_secret=${this._clientSecret}&grant_type=${t}${e}`,{method:"POST"});if(s.ok){let{access_token:n,refresh_token:o}=await s.json();this._authToken=n,this._refreshToken=o,this._resetValidationInterval()}else{let{message:n}=await s.json();throw new Error(n)}}}}catch(e){throw m.error(`Error refreshing app access token: ${e.message}`),e}}async _validateToken(){m.debug("Validating app access token");let e={Authorization:`Bearer ${this._authToken}`};(await F(`${G}/validate`,{headers:e})).status===401&&(m.debug("Access token not valid, refreshing..."),this.refreshToken())}_resetValidationInterval(){clearInterval(this._validationInterval),this._isWebClient||(this._validationInterval=setInterval(this._validateToken.bind(this),36e5))}};Q.exports=d});var N=f((ke,z)=>{var ie=typeof global<"u"?global:typeof window<"u"?window:{},oe=ie.fetch||S("../node_modules/node-fetch/browser.js"),re=R(),ce=w(),v=class{constructor(){v._instance=this}async request(e,t,s=!0){let n=async()=>{let o=await oe(e,t);if(o.status===401){ce.debug("Request received 401 unauthorized response. Refreshing token and retrying...");let r=re.getInstance();try{await r.refreshToken()}catch(i){if(!i.message.includes("web client"))throw i;return o.json()}return t.headers.Authorization=`Bearer ${await r.getToken()}`,n()}else return s?o.json():o.text()};return n()}},ae=new v;z.exports=ae});var fe=f((ye,J)=>{var ue=j(),he=P(),V=E(),$=R(),U=N(),{objectShallowEquals:le,printObject:D}=I(),h=w(),k="https://api.twitch.tv/helix/eventsub/subscriptions";var p=class{constructor(e){if(p._instance)return p._instance;if(!e.identity)throw new Error("TES config must contain 'identity'");if(!e.listener)throw new Error("TES config must contain 'listener'");let{identity:{id:t,secret:s,onAuthenticationFailure:n,accessToken:o,refreshToken:r},listener:{type:i,baseURL:a,secret:c,port:g,ignoreDuplicateMessages:T,ignoreOldMessages:M,server:L,websocketURL:H}}=e;if(!i||i!=="webhook"&&i!=="websocket")throw new Error("TES listener config must have 'type' either 'webhook' or 'websocket'");if(!t)throw new Error("TES identity config must contain 'id'");if(i==="webhook"){if(!s)throw new Error("TES identity config must contain 'secret'");if(!a)throw new Error("TES listener config must contain 'baseURL'");if(!c)throw new Error("TES listener config must contain 'secret'")}else{if(!o)throw new Error("TES identity config must contain 'accessToken'");if(typeof window>"u"&&!n&&!r)throw new Error("TES identity config must contain either 'onAuthenticationFailure' or 'refreshToken'");if(r&&!s)throw new Error("TES identity config must contain 'secret'")}if(p._instance=this,this.clientID=t,this.transportType=i,i==="webhook"){this.baseURL=a,this.whSecret=c,this.port=g||process.env.PORT||8080;let K={ignoreDuplicateMessages:T!==!1,ignoreOldMessages:M!==!1};this.whserver=ue(L,c,K),this._whserverlistener=L?null:this.whserver.listen(this.port)}else this.wsclient=new he(H);e.options=e.options||{},e.options.debug&&h.setLevel("debug"),e.options.logging===!1&&h.setLevel("none"),new $({clientID:t,clientSecret:s,onAuthFailure:n,initialToken:o,refreshToken:r})}getSubscriptions(e){return h.debug(`Getting ${e?`subscriptions for cursor ${e}`:"first page of subscriptions"}`),this._getSubs(`${k}${e?`?after=${e}`:""}`)}getSubscriptionsByType(e,t){return h.debug(`Getting ${t?`subscriptions for cursor ${t}`:"first page of subscriptions"} of type ${e}`),this._getSubs(`${k}?${`type=${encodeURIComponent(e)}`}${t?`&after=${t}`:""}`)}getSubscriptionsByStatus(e,t){return h.debug(`Getting ${t?`subscriptions for cursor ${t}`:"first page of subscriptions"} with status ${e}`),this._getSubs(`${k}?${`status=${encodeURIComponent(e)}`}${t?`&after=${t}`:""}`)}async getSubscription(e,t){t?h.debug(`Getting subscription for type ${e} and condition ${D(t)}`):h.debug(`Getting subscription for id ${e}`);let s,n=async o=>{let r;t?r=await this.getSubscriptionsByType(e,o):r=await this.getSubscriptions(o);let{data:i,pagination:a}=r;s=i.find(c=>t?c.type===e&&le(c.condition,t):c.id===e),!s&&a.cursor&&await n(a.cursor)};return await n(),s}async subscribe(e,t,s="1"){h.debug(`Subscribing to topic with type ${e} and condition ${D(t)}`);let n=await $.getInstance().getToken(),o={"client-id":this.clientID,Authorization:`Bearer ${n}`,"content-type":"application/json"},r={method:this.transportType};if(this.transportType==="webhook")r.callback=`${this.baseURL}/teswh/event`,r.secret=this.whSecret;else{let c=await this.wsclient.getFreeConnection();r.session_id=c}let i={type:e,condition:t,transport:r,version:s},a=await U.request(k,{method:"POST",body:JSON.stringify(i),headers:o});if(a.data){if(this.transportType==="webhook")return new Promise((c,g)=>V.queueSubscription(a,c,g));{let c=a.data[0];return this.wsclient.addSubscription(c.transport.session_id,c),c}}else{let{error:c,status:g,message:T}=a;throw new Error(`${g} ${c}: ${T}`)}}async unsubscribe(e,t){let s=await $.getInstance().getToken(),n={"client-id":this.clientID,Authorization:`Bearer ${s}`},o=async r=>U.request(`${k}?id=${r}`,{method:"DELETE",headers:n},!1);if(t){h.debug(`Unsubscribing from topic with type ${e} and condition ${D(t)}`);let r;if(this.transportType==="webhook"){let i=await this.getSubscription(e,t);i&&(r=i.id)}else r=this.wsclient.findSubscriptionID(e,t);if(r){if(this.transportType==="webhook")return o(r);{let i=await o(r);return i.ok&&this.wsclient.removeSubscription(r),i}}else throw new Error("subscription with given type and condition not found")}else return h.debug(`Unsubscribing from topic ${e}`),o(e)}on(e,t){h.debug(`Adding notification listener for type ${e}`),V.addListener(e,t)}async _getSubs(e){let t=await $.getInstance().getToken(),s={"client-id":this.clientID,Authorization:`Bearer ${t}`};return U.request(e,{headers:s})}static ignoreInMiddleware(e){return(t,s,n)=>t.path==="/teswh/event"?n():e(t,s,n)}};J.exports=p});return fe();})();
/**
 * @license
 * Copyright (c) 2020-2023 Mitchell Adair
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */
//# sourceMappingURL=tes.min.js.map
