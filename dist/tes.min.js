var TES=(()=>{var S=(u=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(u,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):u)(function(u){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+u+'" is not supported')});var f=(u,e)=>()=>(e||u((e={exports:{}}).exports,e),e.exports);var L=f(()=>{});var w=f((pe,O)=>{var A={debug:0,error:1,warn:2,info:3,none:4},x="warn",y=u=>e=>{A[u]>=A[x]&&console.log(`${new Date().toUTCString()} - TESjs - ${e}`)};O.exports={setLevel:u=>x=u,debug:y("debug"),error:y("error"),warn:y("warn"),log:y("info")}});var E=f((we,W)=>{var K=w(),_=class{constructor(){_._instance=this,this._events=this._events||{},this._subscriptionQueue=this._subscriptionQueue||{}}fire(e,t){let s=this._events[e.type];return s?(s.call(this,t,e),!0):(K.warn(`Recieved event for unhandled type: ${e.type}`),!1)}addListener(e,t){if(typeof t!="function")throw TypeError("Event handler must be a function");return this._events[e]=t,this}removeListener(e){return this._events[e]&&delete this._events[e],this}removeAllListeners(){return this._events={},this}queueSubscription(e,t,s){let n=e.data[0].id;return this._subscriptionQueue[n]={data:e,resolve:t,timeout:setTimeout(()=>{s({message:"Subscription verification timed out, this will need to be cleaned up",subscriptionID:n}),delete this._subscriptionQueue[n]},6e5)},this}resolveSubscription(e){if(!this._subscriptionQueue[e])return this;let{resolve:t,timeout:s,data:n}=this._subscriptionQueue[e];return clearTimeout(s),t(n),delete this._subscriptionQueue[e],this}},X=new _;W.exports=X});var I=f((ge,B)=>{B.exports={objectShallowEquals:(u,e)=>{let t=Object.entries(u).every(([s,n])=>!(!(s in e)||n!==e[s]));return t&&(t=Object.entries(e).every(([s,n])=>!(!(s in u)||u[s]!==n))),t},printObject:u=>JSON.stringify(u)}});var P=f((_e,C)=>{var Y=typeof global<"u"?global:typeof window<"u"?window:{},Z=Y.WebSocket||S("../node_modules/ws/index.js"),q=E(),l=w(),{objectShallowEquals:ee}=I(),te="wss://eventsub.wss.twitch.tv/ws",b=class{constructor(){if(b._instance)return b._instance;b._instance=this,this._connections={}}async getFreeConnection(){l.debug("Getting free WebSocket connection");let e=Object.keys(this._connections).find(t=>Object.keys(this._connections[t].subscriptions).length<100);if(e)return l.debug(`Found free WebSocket connection "${e}"`),e;if(Object.keys(this._connections).length<3)return l.debug("No free WebSocket connections, creating a new one..."),new Promise(t=>this._addConnection(t));throw l.debug("No free WebSocket connections, maximum number of connections reached"),new Error("Maximum number of WebSocket connections reached")}removeSubscription(e){Object.values(this._connections).forEach(t=>delete t.subscriptions[e])}addSubscription(e,{id:t,type:s,condition:n}){this._connections[e].subscriptions[t]={type:s,condition:n}}findSubscriptionID(e,t){for(let s in this._connections){let n=this._connections[s],i=Object.keys(n.subscriptions).find(r=>(subscription=n.subscriptions[r],subscription.type===e&&ee(subscription.condition,t)));if(i)return i}}_addConnection(e,t=te){let s=new Z(t);return s.onmessage=n=>{let{metadata:{message_type:i},payload:r}=JSON.parse(n.data);if(i==="session_welcome"){let{session:{id:o,keepalive_timeout_seconds:a}}=r;l.debug(`Received welcome message for session "${o}"`),s.resetTimeout=()=>{s.keepaliveTimeout&&clearTimeout(s.keepaliveTimeout),s.keepaliveTimeout=setTimeout(()=>{q.fire({type:"connection_lost"},s.subscriptions),delete this._connections[o]},a*1e3+100)},s.subscriptions={},this._connections[o]=s,s.resetTimeout(),e(o)}else if(i==="session_keepalive")s.resetTimeout();else if(i==="session_reconnect"){let{session:{id:o,reconnect_url:a}}=r;l.debug(`Received reconnect message for session "${o}"`),this._addConnection(()=>{clearTimeout(s.keepaliveTimeout),s.close()},a)}else if(i==="notification"){s.resetTimeout();let{subscription:o,event:a}=r;l.log(`Received notification for type ${o.type}`),q.fire(o,a)}else if(i==="revocation"){s.resetTimeout();let{subscription:o}=r;l.log(`Received revocation notification for subscription id ${o.id}`),q.fire({...o,type:"revocation"},o),this.removeSubscription(o.id)}else l.log(`Unhandled WebSocket message type "${i}"`)},s.onclose=n=>{let[i]=Object.entries(this._connections).find(([a,c])=>c===s)||[],{code:r,reason:o}=n;l.debug(`WebSocket connection "${i}" closed. ${r}:${o}`),delete this._connections[i]},s}};C.exports=b});var D=f((me,Q)=>{var se=typeof global<"u"?global:typeof window<"u"?window:{},F=se.fetch||S("../node_modules/node-fetch/browser.js"),m=w(),G="https://id.twitch.tv/oauth2",d=class{constructor({clientID:e,clientSecret:t,onAuthFailure:s,initialToken:n,refreshToken:i}){if(this._isWebClient=typeof window<"u",!s&&!this._isWebClient&&(!e||!t))throw new Error("AuthManager config must contain client ID and secret if onAuthFailure not defined");if(d._instance)return d._instance;d._instance=this,this._clientID=e,this._clientSecret=t,this._validationInterval,this._customRefresh=s,this._refreshToken=i,n?this._authToken=n:this.refreshToken()}static getInstance(){return d._instance}getToken(){return new Promise((e,t)=>{let s=new Date,n=()=>{if(this._authToken)e(this._authToken);else if(new Date-s>1e6){let i="Timed out trying to get token";m.error(`${i}.  Something catastrophic has happened!`),t(i)}else setTimeout(n)};n()})}async refreshToken(){m.debug("Getting new app access token");try{if(this._authToken=void 0,this._isWebClient)throw new Error("cannot refresh access token on web client");if(this._customRefresh)this._authToken=await this._customRefresh();else{let e="",t="client_credentials";this._refreshToken&&(t="refresh_token",e=`&refresh_token=${this._refreshToken}`);let s=await F(`${G}/token?client_id=${this._clientID}&client_secret=${this._clientSecret}&grant_type=${t}${e}`,{method:"POST"});if(s.ok){let{access_token:n,refresh_token:i}=await s.json();this._authToken=n,this._refreshToken=i,this._resetValidationInterval()}else{let{message:n}=await s.json();throw new Error(n)}}}catch(e){throw m.error(`Error refreshing app access token: ${e.message}`),e}}async _validateToken(){m.debug("Validating app access token");let e={"client-id":this.clientID,Authorization:`Bearer ${this._authToken}`};(await F(`${G}/validate`,{headers:e})).status===401&&(m.debug("Access token not valid, refreshing..."),this.refreshToken())}_resetValidationInterval(){clearInterval(this._validationInterval),this._validationInterval=setInterval(this._validateToken,36e5)}};Q.exports=d});var N=f((ve,z)=>{var ne=typeof global<"u"?global:typeof window<"u"?window:{},ie=ne.fetch||S("../node_modules/node-fetch/browser.js"),oe=D(),re=w(),v=class{constructor(){v._instance=this}async request(e,t,s=!0){let n=async()=>{let i=await ie(e,t);if(i.status===401){re.debug("Request received 401 unauthorized response. Refreshing token and retrying...");let r=oe.getInstance();try{await r.refreshToken()}catch(o){if(!o.message.includes("web client"))throw o;return i.json()}return t.headers.Authorization=`Bearer ${await r.getToken()}`,n()}else return s?i.json():i.text()};return n()}},ce=new v;z.exports=ce});var le=f((ke,M)=>{var ae=L(),ue=P(),J=E(),$=D(),R=N(),{objectShallowEquals:he,printObject:U}=I(),h=w(),k="https://api.twitch.tv/helix/eventsub/subscriptions";var p=class{constructor(e){if(p._instance)return p._instance;if(!e.identity)throw new Error("TES config must contain 'identity'");if(!e.listener)throw new Error("TES config must contain 'listener'");let{identity:{id:t,secret:s,onAuthenticationFailure:n,accessToken:i,refreshToken:r},listener:{type:o,baseURL:a,secret:c,port:g,ignoreDuplicateMessages:T,ignoreOldMessages:V,server:j}}=e;if(!o||o!=="webhook"&&o!=="websocket")throw new Error("TES listener config must have 'type' either 'webhook' or 'websocket'");if(!t)throw new Error("TES identity config must contain 'id'");if(o==="webhook"){if(!s)throw new Error("TES identity config must contain 'secret'");if(!a)throw new Error("TES listener config must contain 'baseURL'");if(!c)throw new Error("TES listener config must contain 'secret'")}else{if(!i)throw new Error("TES identity config must contain 'accessToken'");if(typeof window>"u"&&!n&&!r)throw new Error("TES identity config must contain either 'onAuthenticationFailure' or 'refreshToken'");if(r&&!s)throw new Error("TES identity config must contain 'secret'")}if(p._instance=this,this.clientID=t,this.transportType=o,o==="webhook"){this.baseURL=a,this.whSecret=c,this.port=g||process.env.PORT||8080;let H={ignoreDuplicateMessages:T!==!1,ignoreOldMessages:V!==!1};this.whserver=ae(j,c,H),this._whserverlistener=j?null:this.whserver.listen(this.port)}else this.wsclient=new ue;e.options=e.options||{},e.options.debug&&h.setLevel("debug"),e.options.logging===!1&&h.setLevel("none"),new $({clientID:t,clientSecret:s,onAuthFailure:n,initialToken:i,refreshToken:r})}getSubscriptions(e){return h.debug(`Getting ${e?`subscriptions for cursor ${e}`:"first page of subscriptions"}`),this._getSubs(`${k}${e?`?after=${e}`:""}`)}getSubscriptionsByType(e,t){return h.debug(`Getting ${t?`subscriptions for cursor ${t}`:"first page of subscriptions"} of type ${e}`),this._getSubs(`${k}?${`type=${encodeURIComponent(e)}`}${t?`&after=${t}`:""}`)}getSubscriptionsByStatus(e,t){return h.debug(`Getting ${t?`subscriptions for cursor ${t}`:"first page of subscriptions"} with status ${e}`),this._getSubs(`${k}?${`status=${encodeURIComponent(e)}`}${t?`&after=${t}`:""}`)}async getSubscription(e,t){t?h.debug(`Getting subscription for type ${e} and condition ${U(t)}`):h.debug(`Getting subscription for id ${e}`);let s,n=async i=>{let r;t?r=await this.getSubscriptionsByType(e,i):r=await this.getSubscriptions(i);let{data:o,pagination:a}=r;s=o.find(c=>t?c.type===e&&he(c.condition,t):c.id===e),!s&&a.cursor&&await n(a.cursor)};return await n(),s}async subscribe(e,t,s="1"){h.debug(`Subscribing to topic with type ${e} and condition ${U(t)}`);let n=await $.getInstance().getToken(),i={"client-id":this.clientID,Authorization:`Bearer ${n}`,"content-type":"application/json"},r={method:this.transportType};if(this.transportType==="webhook")r.callback=`${this.baseURL}/teswh/event`,r.secret=this.whSecret;else{let c=await this.wsclient.getFreeConnection();r.session_id=c}let o={type:e,condition:t,transport:r,version:s},a=await R.request(k,{method:"POST",body:JSON.stringify(o),headers:i});if(a.data){if(this.transportType==="webhook")return new Promise((c,g)=>J.queueSubscription(a,c,g));{let c=a.data[0];return this.wsclient.addSubscription(c.transport.session_id,c),c}}else{let{error:c,status:g,message:T}=a;throw new Error(`${g} ${c}: ${T}`)}}async unsubscribe(e,t){let s=await $.getInstance().getToken(),n={"client-id":this.clientID,Authorization:`Bearer ${s}`},i=async r=>R.request(`${k}?id=${r}`,{method:"DELETE",headers:n},!1);if(t){h.debug(`Unsubscribing from topic with type ${e} and condition ${U(t)}`);let r;if(this.transportType==="webhook"){let o=await this.getSubscription(e,t);o&&(r=o.id)}else r=this.wsclient.findSubscriptionID(e,t);if(r){if(this.transportType==="webhook")return i(r);{let o=await i(r);return o.ok&&this.wsclient.removeSubscription(r),o}}else throw new Error("subscription with given type and condition not found")}else return h.debug(`Unsubscribing from topic ${e}`),i(e)}on(e,t){h.debug(`Adding notification listener for type ${e}`),J.addListener(e,t)}async _getSubs(e){let t=await $.getInstance().getToken(),s={"client-id":this.clientID,Authorization:`Bearer ${t}`};return R.request(e,{headers:s})}static ignoreInMiddleware(e){return(t,s,n)=>t.path==="/teswh/event"?n():e(t,s,n)}};M.exports=p});return le();})();
/**
 * @license
 * Copyright (c) 2020-2023 Mitchell Adair
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */
//# sourceMappingURL=tes.min.js.map
