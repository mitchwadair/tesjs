var TES=(()=>{var S=(u=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(u,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):u)(function(u){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+u+'" is not supported')});var f=(u,e)=>()=>(e||u((e={exports:{}}).exports,e),e.exports);var j=f(()=>{});var g=f((be,x)=>{var L={debug:0,error:1,warn:2,info:3,none:4},A="warn",k=u=>e=>{L[u]>=L[A]&&console.log(`${new Date().toUTCString()} - TESjs - ${e}`)};x.exports={setLevel:u=>A=u,debug:k("debug"),error:k("error"),warn:k("warn"),log:k("info")}});var E=f((we,W)=>{var K=g(),_=class{constructor(){_._instance=this,this._events=this._events||{},this._subscriptionQueue=this._subscriptionQueue||{}}fire(e,t){let n=this._events[e.type];return n?(n.call(this,t,e),!0):(K.warn(`Recieved event for unhandled type: ${e.type}`),!1)}addListener(e,t){if(typeof t!="function")throw TypeError("Event handler must be a function");return this._events[e]=t,this}removeListener(e){return this._events[e]&&delete this._events[e],this}removeAllListeners(){return this._events={},this}queueSubscription(e,t,n){let s=e.data[0].id;return this._subscriptionQueue[s]={data:e,resolve:t,timeout:setTimeout(()=>{n({message:"Subscription verification timed out, this will need to be cleaned up",subscriptionID:s}),delete this._subscriptionQueue[s]},6e5)},this}resolveSubscription(e){if(!this._subscriptionQueue[e])return this;let{resolve:t,timeout:n,data:s}=this._subscriptionQueue[e];return clearTimeout(n),t(s),delete this._subscriptionQueue[e],this}},X=new _;W.exports=X});var I=f((ge,B)=>{B.exports={objectShallowEquals:(u,e)=>{let t=Object.entries(u).every(([n,s])=>!(!(n in e)||s!==e[n]));return t&&(t=Object.entries(e).every(([n,s])=>!(!(n in u)||u[n]!==s))),t},printObject:u=>JSON.stringify(u)}});var P=f((_e,C)=>{var Y=typeof global<"u"?global:typeof window<"u"?window:{},Z=Y.WebSocket||S("../node_modules/ws/index.js"),q=E(),l=g(),{objectShallowEquals:ee}=I(),te="wss://eventsub-beta.wss.twitch.tv/ws",b=class{constructor(){if(b._instance)return b._instance;b._instance=this,this._connections={}}async getFreeConnection(){l.debug("Getting free WebSocket connection");let e=Object.keys(this._connections).find(t=>Object.keys(this._connections[t].subscriptions).length<100);if(e)return l.debug(`Found free WebSocket connection "${e}"`),e;if(Object.keys(this._connections).length<3)return l.debug("No free WebSocket connections, creating a new one..."),new Promise(t=>this._addConnection(t));throw l.debug("No free WebSocket connections, maximum number of connections reached"),new Error("Maximum number of WebSocket connections reached")}removeSubscription(e){Object.values(this._connections).forEach(t=>delete t.subscriptions[e])}addSubscription(e,{id:t,type:n,condition:s}){this._connections[e].subscriptions[t]={type:n,condition:s}}findSubscriptionID(e,t){for(let n in this._connections){let s=this._connections[n],i=Object.keys(s.subscriptions).find(r=>(subscription=s.subscriptions[r],subscription.type===e&&ee(subscription.condition,t)));if(i)return i}}_addConnection(e,t=te){let n=new Z(t);return n.onmessage=s=>{let{metadata:{message_type:i},payload:r}=JSON.parse(s.data);if(i==="session_welcome"){let{session:{id:o,keepalive_timeout_seconds:c}}=r;l.debug(`Received welcome message for session "${o}"`),n.resetTimeout=()=>{n.keepaliveTimeout&&clearTimeout(n.keepaliveTimeout),n.keepaliveTimeout=setTimeout(()=>{q.fire({type:"connection_lost"},n.subscriptions),delete this._connections[o]},c*1e3+100)},n.subscriptions={},this._connections[o]=n,n.resetTimeout(),e(o)}else if(i==="session_keepalive")n.resetTimeout();else if(i==="session_reconnect"){let{session:{id:o,reconnect_url:c}}=r;l.debug(`Received reconnect message for session "${o}"`),this._addConnection(()=>{clearTimeout(n.keepaliveTimeout),n.close()},c)}else if(i==="notification"){n.resetTimeout();let{subscription:o,event:c}=r;l.log(`Received notification for type ${o.type}`),q.fire(o,c)}else if(i==="revocation"){n.resetTimeout();let{subscription:o}=r;l.log(`Received revocation notification for subscription id ${o.id}`),q.fire({...o,type:"revocation"},o),this.removeSubscription(o.id)}else l.log(`Unhandled WebSocket message type "${i}"`)},n.onclose=s=>{let[i]=Object.entries(this._connections).find(([c,a])=>a===n)||[],{code:r,reason:o}=s;l.debug(`WebSocket connection "${i}" closed. ${r}:${o}`),delete this._connections[i]},n}};C.exports=b});var D=f((me,Q)=>{var ne=typeof global<"u"?global:typeof window<"u"?window:{},F=ne.fetch||S("../node_modules/node-fetch/browser.js"),m=g(),G="https://id.twitch.tv/oauth2",p=class{constructor({clientID:e,clientSecret:t,onAuthFailure:n,initialToken:s,refreshToken:i}){if(this._isWebClient=typeof window<"u",!n&&!this._isWebClient&&(!e||!t))throw new Error("AuthManager config must contain client ID and secret if onAuthFailure not defined");if(p._instance)return p._instance;p._instance=this,this._clientID=e,this._clientSecret=t,this._validationInterval,this._customRefresh=n,this._refreshToken=i,s?this._authToken=s:this.refreshToken()}static getInstance(){return p._instance}getToken(){return new Promise((e,t)=>{let n=new Date,s=()=>{if(this._authToken)e(this._authToken);else if(new Date-n>1e6){let i="Timed out trying to get token";m.error(`${i}.  Something catastrophic has happened!`),t(i)}else setTimeout(s)};s()})}async refreshToken(){m.debug("Getting new app access token");try{if(this._authToken=void 0,this._isWebClient)throw new Error("cannot refresh access token on web client");if(this._customRefresh)this._authToken=await this._customRefresh();else{let e="",t="client_credentials";this._refreshToken&&(t="refresh_token",e=`&refresh_token=${this._refreshToken}`);let n=await F(`${G}/token?client_id=${this._clientID}&client_secret=${this._clientSecret}&grant_type=${t}${e}`,{method:"POST"});if(n.ok){let{access_token:s,refresh_token:i}=await n.json();this._authToken=s,this._refreshToken=i,this._resetValidationInterval()}else{let{message:s}=await n.json();throw new Error(s)}}}catch(e){throw m.error(`Error refreshing app access token: ${e.message}`),e}}async _validateToken(){m.debug("Validating app access token");let e={"client-id":this.clientID,Authorization:`Bearer ${this._authToken}`};(await F(`${G}/validate`,{headers:e})).status===401&&(m.debug("Access token not valid, refreshing..."),this.refreshToken())}_resetValidationInterval(){clearInterval(this._validationInterval),this._validationInterval=setInterval(this._validateToken,36e5)}};Q.exports=p});var N=f((ye,z)=>{var se=typeof global<"u"?global:typeof window<"u"?window:{},ie=se.fetch||S("../node_modules/node-fetch/browser.js"),oe=D(),re=g(),y=class{constructor(){y._instance=this}async request(e,t,n=!0){let s=async()=>{let i=await ie(e,t);if(i.status===401){re.debug("Request received 401 unauthorized response. Refreshing token and retrying...");let r=oe.getInstance();try{await r.refreshToken()}catch(o){if(!o.message.includes("web client"))throw o;return i.json()}return t.headers.Authorization=`Bearer ${await r.getToken()}`,s()}else return n?i.json():i.text()};return s()}},ce=new y;z.exports=ce});var le=f((ve,M)=>{var ae=j(),ue=P(),J=E(),T=D(),O=N(),{objectShallowEquals:he,printObject:R}=I(),h=g(),v="https://api.twitch.tv/helix/eventsub/subscriptions",w=class{constructor(e){if(w._instance)return w._instance;if(!e.identity)throw new Error("TES config must contain 'identity'");if(!e.listener)throw new Error("TES config must contain 'listener'");let{identity:{id:t,secret:n,onAuthenticationFailure:s,accessToken:i,refreshToken:r},listener:{type:o,baseURL:c,secret:a,port:d,ignoreDuplicateMessages:$,ignoreOldMessages:V,server:U}}=e;if(!o||o!=="webhook"&&o!=="websocket")throw new Error("TES listener config must have 'type' either 'webhook' or 'websocket'");if(!t)throw new Error("TES identity config must contain 'id'");if(o==="webhook"){if(!n)throw new Error("TES identity config must contain 'secret'");if(!c)throw new Error("TES listener config must contain 'baseURL'");if(!a)throw new Error("TES listener config must contain 'secret'")}else{if(!i)throw new Error("TES identity config must contain 'accessToken'");if(typeof window>"u"&&!s&&!r)throw new Error("TES identity config must contain either 'onAuthenticationFailure' or 'refreshToken'");if(r&&!n)throw new Error("TES identity config must contain 'secret'")}if(w._instance=this,this.clientID=t,this.transportType=o,o==="webhook"){this.baseURL=c,this.whSecret=a,this.port=d||process.env.PORT||8080;let H={ignoreDuplicateMessages:$!==!1,ignoreOldMessages:V!==!1};this.whserver=ae(U,a,H),this._whserverlistener=U?null:this.whserver.listen(this.port)}else this.wsclient=new ue;e.options=e.options||{},e.options.debug&&h.setLevel("debug"),e.options.logging===!1&&h.setLevel("none"),new T({clientID:t,clientSecret:n,onAuthFailure:s,initialToken:i,refreshToken:r})}getSubscriptions(e){return h.debug(`Getting ${e?`subscriptions for cursor ${e}`:"first page of subscriptions"}`),this._getSubs(`${v}${e?`?after=${e}`:""}`)}getSubscriptionsByType(e,t){return h.debug(`Getting ${t?`subscriptions for cursor ${t}`:"first page of subscriptions"} of type ${e}`),this._getSubs(`${v}?${`type=${encodeURIComponent(e)}`}${t?`&after=${t}`:""}`)}getSubscriptionsByStatus(e,t){return h.debug(`Getting ${t?`subscriptions for cursor ${t}`:"first page of subscriptions"} with status ${e}`),this._getSubs(`${v}?${`status=${encodeURIComponent(e)}`}${t?`&after=${t}`:""}`)}async getSubscription(...e){if(e.length>2)throw new Error("getSubscription must have 1 or 2 arguments");let[t,n]=e;e.length===1?h.debug(`Getting subscription for id ${t}`):h.debug(`Getting subscription for type ${t} and condition ${R(n)}`);let s,i=async r=>{let o;e.length===1?o=await this.getSubscriptions(r):o=await this.getSubscriptionsByType(t,r);let{data:c,pagination:a}=o;s=c.find(d=>n?d.type===t&&he(d.condition,n):d.id===t),!s&&a.cursor&&await i(a.cursor)};return await i(),s}async subscribe(e,t,n="1"){h.debug(`Subscribing to topic with type ${e} and condition ${R(t)}`);let s=await T.getInstance().getToken(),i={"client-id":this.clientID,Authorization:`Bearer ${s}`,"content-type":"application/json"},r={method:this.transportType};if(this.transportType==="webhook")r.callback=`${this.baseURL}/teswh/event`,r.secret=this.whSecret;else{let a=await this.wsclient.getFreeConnection();r.session_id=a}let o={type:e,condition:t,transport:r,version:n},c=await O.request(v,{method:"POST",body:JSON.stringify(o),headers:i});if(c.data){if(this.transportType==="webhook")return new Promise((a,d)=>J.queueSubscription(c,a,d));{let a=c.data[0];return this.wsclient.addSubscription(a.transport.session_id,a),a}}else{let{error:a,status:d,message:$}=c;throw new Error(`${d} ${a}: ${$}`)}}async unsubscribe(...e){let t=await T.getInstance().getToken(),n={"client-id":this.clientID,Authorization:`Bearer ${t}`},s=async i=>O.request(`${v}?id=${i}`,{method:"DELETE",headers:n},!1);if(arguments.length===1){let i=e[0];return h.debug(`Unsubscribing from topic ${i}`),s(i)}else if(arguments.length===2){let[i,r]=e;h.debug(`Unsubscribing from topic with type ${i} and condition ${R(r)}`);let o;if(this.transportType==="webhook"){let c=await this.getSubscription(i,r);c&&(o=c.id)}else o=this.wsclient.findSubscriptionID(i,r);if(o){if(this.transportType==="webhook")return s(o);{let c=await s(o);return c.ok&&this.wsclient.removeSubscription(o),c}}else throw new Error("subscription with given type and condition not found")}else throw new Error("unsubscribe must only have 1 or 2 arguments")}on(e,t){h.debug(`Adding notification listener for type ${e}`),J.addListener(e,t)}async _getSubs(e){let t=await T.getInstance().getToken(),n={"client-id":this.clientID,Authorization:`Bearer ${t}`};return O.request(e,{headers:n})}static ignoreInMiddleware(e){return(t,n,s)=>t.path==="/teswh/event"?s():e(t,n,s)}};M.exports=w});return le();})();
//# sourceMappingURL=tes.min.js.map
